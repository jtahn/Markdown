[67. Add Binary](https://leetcode.com/problems/add-binary/)

```python
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        
```

# Description

Given two binary strings `a` and `b`, return _their sum as a binary string_.

**Example 1:**  
**Input:** `a = "11", b = "1"`  
**Output:** `"100"`  

**Example 2:**  
**Input:** `a = "1010", b = "1011"`  
**Output:** `"10101"`  

**Constraints:**
- `1 <= a.length, b.length <= 10^4`
- `a` and `b` consist only of `'0'` or `'1'` characters.
- Each string does not contain leading zeros except for the zero itself.

---

# todo


#/jargon 
- describe solutions where:
	- less optimal theoretically
	- but in practice, most efficient bc relying on python builtins, instead of manual loops


#/jargon 
- bit addition
- carry
- 
# References



# Strategies


## python
#/strats
- python builtins
	- casting to int, adding, and then casting to binary
- (even if this doesnt end up scoring in highest percentiles: still probly worth knowing the python builtin to cast to binary)




## 'binary'

- similar to [[2. Add Two Numbers]], but binary rules
	- addition by hand
		- aka start with least significant digits
			- aka rightmost bits of the input
		- work our way to the most significant bit (left side)
	- track the carry
	- also similarly: likely an O(1) space optimization here
		- p sure i mentioned in that solution to lc2





- binary addition
	- Each bit can only be `0` or `1`
	- If the sum of two bits plus any carry from the previous bit is `2` or `3`, a carry of `1` is passed to the next left bit
		- for new entry at current bit
			- `0` if the sum is `2`
			- `1` if the sum is `3`

- other things
	- For positions where one of the strings may have run out of bits (because one string can be shorter than the other), we treat the missing bit as `0`
	- We also need to consider the possibility of a carry remaining after we've finished processing both strings.

- implementation choices
	- Once the iteration is complete, reverse the answer array to represent the binary sum in the proper order.

- divmod
	- takes two numbers and returns a tuple containing their quotient and remainder
		- quotient = carry
		- remainder = new bit at this pos


- complexity
	- O(n) time
	- O(n) space from the answer array



```python
class Solution:
2    def addBinary(self, a: str, b: str) -> str:
3        ans = []  # List to store the binary result bits
4        i, j, carry = len(a) - 1, len(b) - 1, 0  # Initialize pointers and carry
5
6        # Loop while there are bits to process or a carry
7        while i >= 0 or j >= 0 or carry:
8            # Perform bit addition for current position and update carry
9            carry += (0 if i < 0 else int(a[i])) + (0 if j < 0 else int(b[j]))
10            # Use divmod to get the bit value and the new carry
11            carry, v = divmod(carry, 2)
12            # Append the result bit to the ans list
13            ans.append(str(v))
14            # Move to the previous bits
15            i, j = i - 1, j - 1
16      
17        # Reverse the ans list to get the correct bit order and join to form a binary string
18        return "".join(ans[::-1])
```


---

### neetcode ??

why is he using ord?

```python
# neetcode repo
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        res = ""
        carry = 0

        a, b = a[::-1], b[::-1]
        for i in range(max(len(a), len(b))):
            bitA = ord(a[i]) - ord('0') if i < len(a) else 0
            bitB = ord(b[i]) - ord('0') if i < len(b) else 0

            total = bitA + bitB + carry
            char = str(total % 2)
            res = char + res
            carry = total // 2

        if carry:
            res = "1" + res

        return res

```
