[1197. Minimum Knight Moves](https://leetcode.com/problems/minimum-knight-moves)

```python
class Solution:
    def minKnightMoves(self, x: int, y: int) -> int:
	    
```

# Description

In an **infinite** chess board with coordinates from `-infinity` to `+infinity`, you have a **knight** at square `[0, 0]`.

A knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.

![](!assets/attachments/Pasted%20image%2020240420013403.png)

Return _the minimum number of steps needed to move the knight to the square_ `[x, y]`. It is guaranteed the answer exists.

**Example 1:**  
**Input:** `x = 2, y = 1`  
**Output:** `1`  
**Explanation:** `[0, 0] → [2, 1]`  

**Example 2:**  
**Input:** `x = 5, y = 5`  
**Output:** `4`  
**Explanation:** `[0, 0] → [2, 1] → [4, 2] → [3, 4] → [5, 5]`  

**Constraints:**
- `-300 <= x, y <= 300`
- `0 <= |x| + |y| <= 300`

---



# Strategies


## bfs


Here's how we apply BFS to solve this problem:

- Start by enqueuing the initial position of the knight (0, 0).
- Explore all possible moves a knight can make from its current position.
- For each move, check if the new position matches the target position `[x, y]`. If so, we return the current number of moves taken to get there as our answer.
- If the new position is not the target and has not been visited yet, add it to a queue for further exploration and mark it as visited.
- Increase the move counter each time we've explored all positions at the current level of depth.
- Repeat these steps until the target position is reached.

This process is efficient for finding the shortest path in an unweighted graph—or in this case, an infinite grid—where the distance between all adjacent nodes is equal.

---

bfs: an algorithm well-suited for searching for the shortest path in an unweighted graph. In this case, the graph can be thought of as an infinite 2D grid where each cell is a node and each knight's move represents an edge connecting two nodes.


---


The BFS algorithm works level by level. Starting from a source node, BFS examines all neighbor nodes at the current depth before moving on to nodes at the next depth level. This method ensures that the path found to any node is the shortest one.

### Data Structures Used

To implement BFS:

1. **Queue `q`**: A double-ended queue (`deque` in Python) is used to store nodes to explore in the order they were encountered.
2. **Set `vis`**: A set is used to keep track of visited nodes to prevent re-processing them.

### algo steps

1. **Initialization**: Add the starting position, `[0, 0]`, to the `q` queue and mark it as visited by adding it to the `vis` set. Initialize a step counter `ans` to zero.
    
2. **Processing Nodes**: Continue the process while there are nodes in the queue to explore.
    
    - For each iteration (or level in the BFS), check all nodes currently in the queue.
    - Remove a node from the front of the queue using `popleft()`.
    - If this node is the target `[x, y]`, return the `ans` as the minimum number of steps.
3. **Exploring Neighbors**: For the current node at position `(i, j)`, calculate all possible positions where the knight can move based on the defined moves in `dirs`.
    
    - If a neighbor node `(c, d)` has not been visited, mark it as visited by adding it to the `vis` set and append it to the queue `q`.
4. **Incrementing Steps**: After exploring all nodes at the current depth, increment the `ans` counter by 1 before moving on to nodes at the next depth level.
    
5. **Termination**: If the target node `[x, y]` is reached, the current value of `ans` will be the minimum number of steps needed, and the function returns this value.
    

The loop continues until we reach the target node, at which point the function exits with the answer. The BFS guarantees that when we reach `[x, y]`, it will be the shortest path due to the way BFS explores all paths of `n` length before moving to paths of `n+1` length.

By using a set `vis`, the algorithm ensures each node is processed only once, avoiding redundant calculations and cycles which is crucial for efficiency on an infinite grid.

Overall, the BFS approach is efficient and guarantees that the shortest path will be found in a scenario like this where each move is considered of equal 'weight' or distance.

---


This problem can be solved using the BFS shortest path model. The search space for this problem is not large, so we can directly use the naive BFS. The solution below also provides the code for bidirectional BFS for reference.

Bidirectional BFS is a common optimization method for BFS. The main implementation ideas are as follows:

1. Create two queues, q1 and q2, for “start -> end” and “end -> start” search directions, respectively.
2. Create two hash maps, m1 and m2, to record the visited nodes and their corresponding expansion times (steps).
3. During each search, prioritize the queue with fewer elements for search expansion. If a node visited from the other direction is found during the expansion, it means the shortest path has been found.
4. If one of the queues is empty, it means that the search in the current direction cannot continue, indicating that the start and end points are not connected, and there is no need to continue the search.


```python
class Solution:
    def minKnightMoves(self, x: int, y: int) -> int:
	    queue = deque([(0,0)])
	    moves_count = 0
	    visited = {(0,0)}
		dirs = ((-2,1), (-1,2), (1,2), (2,1), (2,-1), (1,-2), (-1,-2), (-2,-1))
		while queue:
			for _ in range(len(queue)):
				cur_i, cur_j = queue.popleft()
				if (cur_i, cur_j) == (x,y):
					return moves_count
				for (d_i, d_j) in dirs:
					new_i, new_j = cur_i + d_i, cur_j + d_j
					if (new_i, new_j) not in visited:
						visited.add((new_i, new_j))
						queue.append((new_i, new_j))
			moves_count += 1
		return -1

```


### Time Complexity

To analyze the time complexity, let's consider the increments to coordinates as potential moves from one square to another. For each move, we have 8 possible directions in which the knight can move. The BFS algorithm ensures that every position is visited only once, thanks to the `vis` set which tracks the visited positions.

Since the board is infinite, the maximum distance from the origin in terms of the number of moves can be represented by `max(abs(x), abs(y))`. This is because, in the worst-case scenario, we can consider moving diagonally (in L-shaped movements) towards the target, which is roughly `max(abs(x), abs(y))` moves away. However, the actual number of moves requires considering the peculiarities of knight's movements. The BFS will have a branching factor of at most 8 (the possible moves the knight can make), and the depth will be proportional to the distance from the origin to the target.

Thus, the time complexity can be approximated as `O(8^(d))` where `d` is the depth of the BFS, or more accurately, `O((max(abs(x), abs(y)))^2)` because each layer of BFS (which corresponds to one knight's move) potentially adds up to 8 new positions in the queue.

### Space Complexity

The space complexity is primarily dictated by the storage required for the `vis` set and the `q` queue. The `vis` set contains all the unique positions we have visited during the BFS.

- The space taken by the `vis` set is proportional to the number of elements in it, which is the number of unique positions the algorithm will visit, roughly the same as the time complexity, leading to an `O((max(abs(x), abs(y)))^2)` space complexity.
- The `q` queue stores the positions that need to be explored. In the worst case, the queue could store all of the positions that we visit. Hence, the space complexity contributed by the `q` is similar to the vis set, `O((max(abs(x), abs(y)))^2)`.

Overall, the space complexity of the algorithm is `O((max(abs(x), abs(y)))^2)`.