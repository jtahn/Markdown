[15. 3Sum](https://leetcode.com/problems/3sum/)

```
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        
```

Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

**Example 1:**  
**Input:** `nums = [-1,0,1,2,-1,-4]`  
**Output:** `[[-1,-1,2],[-1,0,1]]`  
**Explanation:**  
```
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
```

**Example 2:**  
**Input:** `nums = [0,1,1]`  
**Output:** `[]`  
**Explanation:** The only possible triplet does not sum up to 0.  

**Example 3:**  
**Input:** `nums = [0,0,0]`  
**Output:** `[[0,0,0]]`  
**Explanation:** The only possible triplet sums up to 0.  

**Constraints:**
- `3 <= nums.length <= 3000`
- `-10^5 <= nums[i] <= 10^5`

---

# todo


- for both ‘main approaches’ solutions, when we do the 2sum subproblem:
	- make it clear we use/cite the 2sum, but a variant
	- btw, iirc i need to cite a diff problem for each approach
	- the 2sum variants that are cited
		- unsorted: [1. Two Sum](1.%20Two%20Sum.md)
		- sorted: [167. Two Sum II - Input Array Is Sorted](167.%20Two%20Sum%20II%20-%20Input%20Array%20Is%20Sorted.md)
	- for both cited problems: mention that i use a variant
		- bc those 2sum problems, we assume unique solution
		- but here: could be multiple solutions
			- (dont really need more details about how you adjust implementation
				- bc this is obvious from code)

- there’s like 2 major steps here:
	- step 1: find solutions
	- step 2: decide if duplicate / how to handle duplicates


- for step 1:
	- key idea: just break it down into subproblems:
		- for each entry: treat rest of array as 2sum

- for step 2:
	- approach idea 1: track existence via a set
		- check if solution already found
			- aka existence
			- aka set
			- note: ‘same’ solution: can be any order
			- so need to pick a ‘key’ you store for each solution
				- ie ‘representative for equivalent things’’
				- standard choice: sorted tuple
				- (btw: is ‘key’ the correct jargon? aka what do you call elements of a set)
	- approach idea 2 (which basically combines with step 1):
		- do some preprocessing and/or iterate in a way, that guarantees that if we find a solution, it’s unique
		- possible intuition here:
			- think about what the key/representatives look like for idea 1
			- see if you can modify the input so that computed solutions are always exactly the ‘representative’
			- so here: representative is sorted tuple; so lets just sort the input
				- and then skip iterations when it’s ‘same element as prev iteration’
				- imo: ‘skip iterations’ might actually be a separate key idea..ie there’s like a mini ‘2 pointer’ fundy going on here
		- idea???/future: this idea, maybe there’s a more fundy observation...bc the ‘sort array at the start’ enables not only ‘easy to determine duplicates’, but also ‘skip iterations’
			- tbh: ‘skip iterations’ is really the thing here..this is whats allowing us to ‘not do a duplicate check’
			- so imo..this truly is like a ‘2 pointer idea’ going on here (separate from the fact that we 2 pointers to solve the sorted 2sum subproblem)


- approach idea 2, finding ‘best’ way to explain ‘skipping iterations’:
- need to explain why skipping iterations:
	- guarantees unique
	- doesnt lose solutions
	- aka: only solutions we ‘skip’ are non-unique solutions
	- maybe im thinking about this the wrong way? maybe:
		- observe that we are ‘obviously computing duplicate solutions if we do full iteration
		- then we realize how to iterate more smartly to avoid duplicates
	- so maybe key idea for ‘sorting’:
		- the idea is to preprocess array so that when we compute solutions, it is always the representative
		- maybe this is same complexity as ‘unsorted’ array:
			- todo: compute what the time complexity contribution is for sorting each solution
			- yea, i need to add that time complexity contribution!
			- ehh its negligible tho...for each solution, its log(3)=O(1)...

- what iterations are ‘duplicates’ ie what iterations can we skip
	- for both first and second pointer: only run if this is a unique number for this pointer
		- bc we’ve already run an iteration where wlog, first pointer was at this number
		- (and same arg for second pointer)
	- so above proves that indeed, we are exactly skipping ‘duplicate’ solutions
	- !! the key point is that; bc we presorted array: we know are only computing ‘representative’ solutions
		- then: skipping iterations means we skip all ‘duplicate’ representatives
		- so these 2 facts combined..convincing enough that we exactly compute unique solutions?


## complexity analysis:

- ‘set’ approach:
	- O(n^3) space bc set isnt the solution
		- need to convert set to a list at the end
		- num of possible solutions is n^3, bc triplets
			- uhh actually TODO: i dont think this is true
		- figure out what actually is the max possible num solutions...there’s no way its possible for every triplet to be a solution, 
		- (but point is: space complexity is noticeable)
		- (btw: theres also space complexity for th 2sum subproblem, bc need a dict there bc unsorted...but its not going to be higher than the ttl problem complexity, so it doesnt matter tbh)


- sort then skip iterations:
	- O(1) space bc the ‘list we’re building’ is ultimately the solution (so is considered O(1))








# Brute force
- for each valid triplet (aka triple loop)
	- check if the triple sums to zero
	- (possibly need to check if i've already found that triplet, if i don't loop in a way that avoids duplicates)
- complexity
	- O(n^3) time

# Two Pointer
```
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()

        for i, a in enumerate(nums):
            # Skip positive integers
            if a > 0:
                break

            if i > 0 and a == nums[i - 1]:
                continue

            l, r = i + 1, len(nums) - 1
            while l < r:
                threeSum = a + nums[l] + nums[r]
                if threeSum > 0:
                    r -= 1
                elif threeSum < 0:
                    l += 1
                else:
                    res.append([a, nums[l], nums[r]])
                    l += 1
                    r -= 1
                    while nums[l] == nums[l - 1] and l < r:
                        l += 1
                        
        return res
```

- strategy
	- sort array
	- then iterate over nodes: 
		- for each node, then on rest of the array we are solving a subproblem that is similar to [167. Two Sum II - Input Array Is Sorted](167.%20Two%20Sum%20II%20-%20Input%20Array%20Is%20Sorted.md)
			- (only difference is we allow multiple solutions)
			- ie want to find two numbers that sum to `- (current node)`
			- so use technique from that problem
			- in general, two pointer is the optimal solution
			- hashmap is also optimal here, because entry values are bounded
				- i.e. technically O(1) space, bc entries have absolute value at most 2 x 10^5
			- (but probly better to use two pointer...its more optimal for the 'unbounded entries' variant of this problem, which seems useful)
- optimization
	- during iteration, break once we reach a positive number: bc we can't sum to zero using numbers after it (bc they are also positive)
- complexity
	- time
		- O(n^2) total
			- O(n logn) to sort 
			- O(n) to loop over nodes
				- for each, another O(n) to solve the "sorted 2sum" subproblem
	- space complexity
		- O(n) if i'm lazy: use a set to store found solutions (this way, no duplicates)
		- O(1) if you iterate in a way that guarantees unique solutions only
			- (can do this bc array is sorted)
			- whenever you finish an iteration for `i`, then you increment `i` until you reach a new value
			- whenever you find a solution, then you increment `l` until you reach a new value
			- observe all solutions satisfy `nums[i] <== nums[l] <= nums[r]`
			- so incrementing i and l in the manner mentioned above, means that subsequent solutions in the inner loop are guaranteed to satisfy second number larger; and subsequent solutions from next iteration of outr loop, have first number larger...
			- ie when you move to the next iteration, you advance iterator/pointers until you actually encounter a new number
			- probably better explanation:
				- if a solution has all diff numbers, then we're guaranteed to find it in the increasing order of numbers...ie `[-3,1,2]` is always found in that order
				- if solution has some repeated numbers...how is duplicating this avoided????
			- nah my original explanation was best; it's basically like 'proof by induction kind of thing'
				- first solution is different from everything after, bc you know either first or second number is strictly larger
				- second solution different from everything after, for the same reason
				- and etc etc