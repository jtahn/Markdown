[815. Bus Routes](https://leetcode.com/problems/bus-routes/)

```python
class Solution:
    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:
        
```

# Description

You are given an array `routes` representing bus routes where `routes[i]` is a bus route that the `i^th` bus repeats forever.

- For example, if `routes[0] = [1, 5, 7]`, this means that the `0^th` bus travels in the sequence `1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ...` forever.

You will start at the bus stop `source` (You are not on any bus initially), and you want to go to the bus stop `target`. You can travel between bus stops by buses only.

Return _the least number of buses you must take to travel from_ `source` _to_ `target`. Return `-1` if it is not possible.

**Example 1:**  
**Input:** `routes = [[1,2,7],[3,6,7]], source = 1, target = 6`  
**Output:** `2`  
**Explanation:** The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.

**Example 2:**  
**Input:** `routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12`  
**Output:** `-1`  

**Constraints:**
- `1 <= routes.length <= 500`.
- `1 <= routes[i].length <= 10^5`
- All the values of `routes[i]` are **unique**.
- `sum(routes[i].length) <= 10^5`
- `0 <= routes[i][j] < 10^6`
- `0 <= source, target < 10^6`

---


# todo

#/strats 
- https://leetcode.com/problems/bus-routes/solutions/1657162/java-modified-bfs-comments-and-explanation-with-diagrams/
	- diagrams for why this is modified bfs
- https://leetcode.com/problems/bus-routes/editorial/
	- approach 1: nodes =stops; bfs
	- appraoch 2: nodes = routes; bfs
- https://leetcode.com/problems/bus-routes/solutions/4279320/c-java-python-javascript-2-approaches-explained/
	- also explains both approaches
- https://leetcode.com/problems/bus-routes/solutions/151289/python-bfs-with-explanation/
	- python short; shorter if you check comments
- https://leetcode.com/problems/bus-routes/solutions/4279742/video-give-me-10-minutes-beats-99-53-how-we-think-about-a-solution/
	- video
	- short python code in comments
- https://leetcode.com/problems/bus-routes/solutions/1072394/python-bfs-solution/
	- why set and not list in graph defaultdict?
		- If we only want to check, whether an element is present or not, OR we want to traverse the elements regardless of their order, we can use SET. Set is unordered and in most cases of graph, we don't really care in the order, we just traverse the nodes and children, regardless of the order they appear. We can use LIST but if we only want to check if element is present or not or just want to access the element, SET is fine as lookup in SET is O(1) while Lookup in LIST is O(n).
- https://leetcode.com/problems/bus-routes/solutions/122771/c-java-python-bfs-solution/
	- probly useful, but look at it last

#/meta 
- when trying to figure out strat from the code:
	- first look at the 'main' data structures
		- then the 'aux' data structures
	- probly over time, i get a feel for: given a collection of data structures, which ones are probly the 'main' ones that will help indicate the strat
		- ie: if there's a stack/queue, then that's probly the main one?
- examples
	- [[815. Bus Routes]]
		- look at queue to immediately see if it's 'nodes=routes' or 'nodes=stops'


#/code #/style
- when naming vars, which is better?
	- option 1: really descriptive var names
	- option 2: var names that are basically identical to the 'abstract templates' you see in textbooks
- imo i prefer the latter if possible:
	- the 'descriptive names' kind of clutter/hide what the real structure of the problem is
	- and part of the whole point of graph problems is to figure out the abstract model/structure is anyways...
		- so just explain this briefly before the code
		- and then now it's easy to see why the code is correct, despite non-descriptive names
- btw, i bet this applies to other types of problems too...
	- aka for dp strats...always name the array `dp`
- for bfs:
	- [[_refs/01 competitive programming/halim1.pdf#page=227|halim1, 4.2.3 Breadth First Search (BFS)]]
		- queue, node, neighbor: q, u, v
	- [[_refs/01 competitive programming/halim1.pdf#page=229|halim1, 4.2.5 Flood Fill (Implicit 2D Grid Graph)]]
		- ans, r, c, dr, dc


#/code 
- what are best-practice names for dictionaries?
	- and other structure too


#/refs 
- https://github.com/hwennnn/leetcode-solutions


#/problems 
- graph problems that practice the best way to build adjacency lists for a variety of inputs
	- (ie where adjacency list is actually required)
	- i want the 'hard part' of the problem being, how to build the adjacency list optimally


#/meta
- careful with leetcode top solutions
	- sometimes, it's because the test cases are not comprehensive, so code that isn't necessarily better, just happens to run a lot faster
	- example:
		- [[815. Bus Routes]]
			- the 'nodes=routes' strats: if you initialize the bfs on routes containing target (instead of source): you immediately jump to 99pct time complexity 



# References

## #graphs/model 
- model 1: undirected graph
	- vertex = bus route
	- edge = routes intersect; ie buses share a common stop
	- strat: 
		- bfs shortest path
			- init bfs queue with all routes that contain our source
			- return when we find a route that contains target
				- return depth of the bfs

	
	

## #graphs/bellman-ford 
- refs
	- https://cp-algorithms.com/graph/bellman_ford.html
	- https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm#Algorithm
	- [[_refs/01 competitive programming/halim1.pdf#page=264|halim1, 4.4.4 On Small Graph (with Negative Cycle): Bellman-Ford]]
- note:
	- [[_refs/01 competitive programming/halim1.pdf#page=267|halim1, 4.4.5 SSSP in Programming Contests]]
		- basically advises:
			- use bfs if unweighted
			- use dijkstra if non-negative weights
			- aka don't use b-f unless you absolutely have to (aka negative weights)

## tbd
- the big thing here is efficiency
- there's different strats AND different implementations, that score wildly differently





## #graphs/traversal 
- you need to immediately populate the visited set on queueing
	- you cannot wait until you 'process' the node
	- otherwise you might add a bunch of duplicates to the queue


# Strategies


## nodes=routes; bfs

- the subtle/difficulty here is understanding what structures you actually need
	- poor choices here lead to 10x more inefficient code

- bfs simply means:
	- we want a way that is overall efficient to find neighbors
	- note: for each node, we only have to find neighbors once
		- so it doesn't make sense to have structures that are so expensive to build, that they override any efficiency gains when we actually use them

- neighbors: buses share a common stop


- edge = routes intersect; ie routes share a common stop
	- so actually, the best thing to do here is:
		- iterate through that routes stops
		- find what unvisited routes have those (unvisited) stops
			- via dict: stops to routes
- don't need anything else!
	- ie no need to convert routes into sets


- #/fundy i should understand exactly why we don't need a graph representation here
	- iirc there was another problem too, where: didn't need a graph rep...and that problem too, the algo was essentially just, 'do a traversal'

- i think here:
	- if you create a structure to make it more efficient to build the graph representation
	- then you can probly just directly use that structure to efficiently find neighbors
		- and if all you need to do is a traversal, then no need for graph rep


to find if routes contain a common stop: you're going to need some kind of hashing with stops being keys:
- 2 choices:
	- turn routes into a set
		- so stops are the key in each route
	- dict of stop to routes
- actually: both are same complexity?
	- same time bc have to iterate through all routes
	- and same space bc each structure is exactly all the (route,stop) pairs

- i think point is: both are same cost to build
	- and the second one is far more useful for finding neighbors in our situation:
		- for every route: in linear time can scan its stops and find its neighbors
		- cant do better than that



- deciding if there is an edge btwn 2 routes:
	- need to be able to quickly determine if a stop is inside a route
...
blegh idk how to explain this..imo just 'do it'

is it worth keeping what 'not' to do?






```python
# 1307ms
class Solution:
    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:
        if source == target:
            return 0
        
        stops = defaultdict(set)
        for i, route in enumerate(routes):
            for stop in route:
                stops[stop].add(i)
        
        q = deque(stops[source])
        visited = set(stops[source])
        ans = 0

        while q:
            ans += 1
            for _ in range(len(q)):
                u = q.popleft()
                if target in routes[u]:
                    return ans
                for stop in routes[u]:
                    for v in stops[stop]:
                        if v not in visited:
                            visited.add(v)
                            q.append(v)
        return -1
```




## nodes = stops; bfs
- examples
	- https://walkccc.me/LeetCode/problems/815/#__tabbed_1_3


- do we also need 'visited routes'?

```python
# 357ms
class Solution:
    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:

        if source == target:
            return 0

        stops = defaultdict(list)
        for i, route in enumerate(routes):
            for stop in route:
                stops[stop].append(i)
        
        if source not in stops or target not in stops:
            return -1

        q = collections.deque(source)
        visited_stop = set(source)
		visited_route = set()
		ans = 0

        while q:
            ans += 1
            for _ in range(len(q)):
                u = q.popleft()

                for route in stops[u]:
                    if route in visited_route:
                        continue
                    visited_route.add(route)

                    for v in routes[route]:
                        if v in visited_stop:
                            continue

                        if v == target:
                            return ans
                        
                        q.append(v)
                        visited_stop.add(v)
        return -1



```




## ???

```python
# 357ms
class Solution:
    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:
        if source == target:
	        return 0

        g = []

        for r in routes:
            g.append(set(r))
            if source in g[-1]:
                sourceRoute = len(g) - 1

        q = collections.deque(source)
		visited = set(source)
		
        distance = 1
        while q:
            for _ in range(len(q)):
                currStop = q.popleft()
                for routeId, stops in enumerate(g):
                    if currStop not in stops:
                        continue
                    if target in stops:
                        return distance
                    for stop in stops:
                        if stop in visited:
                            continue
                        visited.add(stop)
                        q.append(stop)
                    g[routeId] = set()

            distance += 1
        return -1
```








## nodes = ?; bellman-ford
- strat
	- 'relaxation'; repeatedly iterate through routes and 'relax' stops distances
		- for each route:
			- go through it's stops to determine min stop on the route
			- then go through it's stops again and relax values

- examples
	- - https://leetcode.com/problems/bus-routes/solutions/4277892/beats-100-explained-with-video-modified-bellman-ford-visualized-too/
	- https://medium.com/@bsinghrathore32/leetcode-815-bus-routes-0e79c1fd391b

- maybe: b-f the best strat to use here for space complexity?


```python
# 357ms
class Solution:
    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:
        if source == target:
            return 0

        max_stop = max(max(route) for route in routes)
        if max_stop < target or source > max_stop:
            return -1

        n = len(routes)
        min_buses_to_reach = [float('inf')] * (max_stop + 1)
        min_buses_to_reach[source] = 0

        flag = True
        while flag:
            flag = False
            for route in routes:
                mini = float('inf')
                for stop in route:
                    mini = min(mini, min_buses_to_reach[stop])
                mini += 1
                for stop in route:
                    if min_buses_to_reach[stop] > mini:
                        min_buses_to_reach[stop] = mini
                        flag = True

        return min_buses_to_reach[target] if min_buses_to_reach[target] < float('inf') else -1
```




```python
# 32mb
class Solution(object):
    def numBusesToDestination(self, routes, source, target):
        if source == target:
            return 0

        max_stop = max(max(route) for route in routes)
        if max_stop < target or source > max_stop:
            return -1

        n = len(routes)
        min_buses_to_reach = [float('inf')] * (max_stop + 1)
        min_buses_to_reach[source] = 0

        flag = True
        while flag:
            flag = False
            for route in routes:
                mini = float('inf')
                for stop in route:
                    mini = min(mini, min_buses_to_reach[stop])
                mini += 1
                for stop in route:
                    if min_buses_to_reach[stop] > mini:
                        min_buses_to_reach[stop] = mini
                        flag = True

        return min_buses_to_reach[target] if min_buses_to_reach[target] < float('inf') else -1
```


