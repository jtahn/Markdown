[815. Bus Routes](https://leetcode.com/problems/bus-routes/)

```python
class Solution:
    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:
        
```

# Description

You are given an array `routes` representing bus routes where `routes[i]` is a bus route that the `i^th` bus repeats forever.

- For example, if `routes[0] = [1, 5, 7]`, this means that the `0^th` bus travels in the sequence `1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ...` forever.

You will start at the bus stop `source` (You are not on any bus initially), and you want to go to the bus stop `target`. You can travel between bus stops by buses only.

Return _the least number of buses you must take to travel from_ `source` _to_ `target`. Return `-1` if it is not possible.

**Example 1:**  
**Input:** `routes = [[1,2,7],[3,6,7]], source = 1, target = 6`  
**Output:** `2`  
**Explanation:** The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.

**Example 2:**  
**Input:** `routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12`  
**Output:** `-1`  

**Constraints:**
- `1 <= routes.length <= 500`.
- `1 <= routes[i].length <= 10^5`
- All the values of `routes[i]` are **unique**.
- `sum(routes[i].length) <= 10^5`
- `0 <= routes[i][j] < 10^6`
- `0 <= source, target < 10^6`

---


# todo

#/strats 

- https://leetcode.com/problems/bus-routes/solutions/1657162/java-modified-bfs-comments-and-explanation-with-diagrams/
	- diagrams for why this is modified bfs
- https://leetcode.com/problems/bus-routes/editorial/
	- approach 1: nodes =stops; bfs
	- appraoch 2: nodes = routes; bfs
- https://leetcode.com/problems/bus-routes/solutions/4279320/c-java-python-javascript-2-approaches-explained/
	- also explains both approaches
- https://leetcode.com/problems/bus-routes/solutions/4277892/beats-100-explained-with-video-modified-bellman-ford-visualized-too/
	- seems the bfs algo used is bellman ford
- https://leetcode.com/problems/bus-routes/solutions/151289/python-bfs-with-explanation/
	- python short; shorter if you check comments
- https://leetcode.com/problems/bus-routes/solutions/4279742/video-give-me-10-minutes-beats-99-53-how-we-think-about-a-solution/
	- video
	- short python code in comments
- https://leetcode.com/problems/bus-routes/solutions/1072394/python-bfs-solution/
	- why set and not list in graph defaultdict?
		- If we only want to check, whether an element is present or not, OR we want to traverse the elements regardless of their order, we can use SET. Set is unordered and in most cases of graph, we don't really care in the order, we just traverse the nodes and children, regardless of the order they appear. We can use LIST but if we only want to check if element is present or not or just want to access the element, SET is fine as lookup in SET is O(1) while Lookup in LIST is O(n).
- https://leetcode.com/problems/bus-routes/solutions/122771/c-java-python-bfs-solution/
	- probly useful, but look at it last


# Strategies


## bfs


To solve the bus routes problem, we can think of each bus route as a node in a graph, where edges connect nodes if the buses share a common bus stop. The problem then reduces to finding the shortest path in this graph from the node representing the bus we can take at our source to the node representing the bus that passes through our target.

Here's the step-by-step strategy behind the solution:

1. First, we simplify the representation of routes by converting each bus route list into a set for faster look-up times. This is because we'll often need to check if a certain bus route contains a specific stop.
    
2. The second step is to create a mapping that tells us which bus routes pass through each bus stop. This is done using a dictionary where each key is a bus stop, and the value is a list of bus routes that pass through that stop.
    
3. Next, a graph is created where each node represents a bus route, and edges only exist between nodes (routes) that have at least one bus stop in common.
    
4. The fourth step involves a [breadth-first search](https://algo.monster/problems/bfs_intro) (BFS) on the graph. BFS is chosen because it explores all routes from the current bus stop before moving to routes that are two stops away, thereby ensuring that the minimum number of buses is taken.
    
5. We start the BFS with all bus routes that pass through the `source` stop, tracking visited routes. If the target stop is in any currently visited route, we return the number of buses (depth of the BFS).
    
6. If the target is not reached directly, we then expand to neighboring routes (routes sharing at least one common stop) in the BFS, again checking if the target is there at each step.
    
7. The BFS continues until we either find the target or exhaust all possibilities.
    

If the `target` is found, we return the current depth of the BFS (i.e., the number of buses we've virtually 'taken'). If we've gone through the entire graph (explored all connected routes) without finding the `target`, we return `-1`, indicating that the journey is not possible with the given bus routes.


---


The solution provided leverages several computing concepts, including graph theory, hash sets, hash maps (a.k.a dictionaries in Python), [breadth-first search](https://algo.monster/problems/bfs_intro) (BFS), and queues.

### Algorithms and Data Structures Used:

- **Graph Theory**: The solution treats the bus routes as nodes in a graph and the common stops between them as edges, abstracting the problem into finding the shortest path in a graph.
    
- **Hash Set**: Each bus route is converted into a set for constant-time lookup to determine whether a route contains a particular stop.
    
- **Hash Map / Dictionary**: Two dictionaries are utilized: one for mapping each stop to the list of routes passing through it, and another for representing the adjacency list of the route graph.
    
- **[Breadth-First Search](https://algo.monster/problems/bfs_intro) (BFS)**: BFS is used to traverse the graph levels, keeping track of the number of 'hops' or bus changes required to reach the destination.
    
- **Queue**: A queue is pivotal for implementing BFS. The Python collection `deque` is used for its efficient append and popleft operations.
    

### Implementation Steps:

1. **Preprocessing Routes**: The routes list is converted into a list of sets `s` for O(1) access to check if a target is in a particular route.
    
2. **Mapping Stops to Routes**: A dictionary `d` is created where each key is a stop and each value is a list of routes passing through that stop.
    
3. **Building the Graph**: Another dictionary `g` represents the graph, which is essentially an adjacency list. Two routes are connected in this graph if they have at least one common stop.
    
4. **Initial BFS Setup**: A queue `q` is initiated with all the routes that have the `source` stop. A hash set `vis` is also defined to record visited routes to prevent processing the same route multiple times.
    
5. **BFS Execution**:
    
    - The BFS loop begins with an assumption that we have taken one bus (since we are starting at the `source`); hence `ans` is initialized to 1.
    - It processes nodes in the current BFS level by popping from the left of the queue. For each route at the current BFS level:
        - If the `target` is inside the current route's set, we return `ans` which represents the number of buses taken until now.
        - Otherwise, add all connected routes to the queue that have not already been visited.
    - After processing all routes in the current BFS level, increment `ans`, symbolizing a transition to the next level—which represents taking another bus.
6. **Return Result**: If the BFS loop completes without returning, then there is no route to the `target`, and `-1` is returned.
    

The implementation effectively finds the minimum number of bus changes required to go from `source` to `target` in a graph that represents the shared stops between bus routes.


---





```python
class Solution:
	def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:
		if source == target:
			return 0
		sets_of_routes = [set(route)] for route in routes]
```



```python
9        # Convert each route to a set for faster checks later on.
10        sets_of_routes = [set(route) for route in routes]
11      
12        # Create a dictionary where each stop maps to a list of buses (routes) that visit that stop.
13        stop_to_buses_dict = defaultdict(list)
14        for i, route in enumerate(routes):
15            for stop in route:
16                stop_to_buses_dict[stop].append(i)
17      
18        # Build a graph where each node represents a bus and edges connect buses that share a common stop.
19        bus_graph = defaultdict(list)
20        for buses in stop_to_buses_dict.values():
21            num_buses = len(buses)
22            for i in range(num_buses):
23                for j in range(i + 1, num_buses):
24                    first, second = buses[i], buses[j]
25                    bus_graph[first].append(second)
26                    bus_graph[second].append(first)
27      
28        # Start BFS from the buses that can be taken from the source stop.
29        queue = deque(stop_to_buses_dict[source])
30        number_of_buses = 1
31        visited_buses = set(stop_to_buses_dict[source])
32      
33        while queue:
34            # Process all nodes on the current level.
35            for _ in range(len(queue)):
36                current_bus = queue.popleft()
37              
38                # If the target stop is in the current bus's route, return the number of buses needed.
39                if target in sets_of_routes[current_bus]:
40                    return number_of_buses
41              
42                # Check unvisited buses that can be reached from the current bus.
43                for adjacent_bus in bus_graph[current_bus]:
44                    if adjacent_bus not in visited_buses:
45                        visited_buses.add(adjacent_bus)
46                        queue.append(adjacent_bus)
47          
48            # Increment the number of buses needed as we are now moving to the next level in BFS.
49            number_of_buses += 1
50      
51        # If no path is found, return -1 to signify that destination cannot be reached.
52        return -1
```



### Time Complexity

The time complexity of the code is composed of three main parts:

- Constructing the `s` list: This loops over each route and each stop within that route, which results in `O(R*S)` time complexity, where `R` is the number of routes and `S` is the average number of stops per route.
- Building the graph `g`: This involves nested loops over each stop's routes. In the worst case, if every stop is on every route, the inner loop could run `O(R^2)` times for each stop. However, this is not very likely in a real-world scenario. Generally, the number of buses a stop connects to would be a smaller constant `K`. So this part is more accurately represented as `O(S*K^2)`, where `K` is the average number of connecting routes to any stop.
- BFS traversal of the graph: In the worst case, this could visit every vertex and edge in the graph constructed in the previous step. The vertices in the graph are the bus routes, and the edges are connections between routes that share a common stop. At worst, this results in `O(V+E)` complexity, where `V` is the number of vertices (bus routes) and `E` is the number of edges (connections between routes).

Hence, the overall time complexity is approximately `O(R*S + S*K^2 + V+E)`.

### Space Complexity

The space complexity of the code is determined by:

- The `s` list: This list stores a set of stops for each route, which requires `O(R*S)` space.
- The `d` dictionary: This contains at most `S` keys (each stop) and, for each key, a list of routes that pass by that stop. So, this contributes an additional `O(S*K)` space complexity where `K` is the average number of routes per stop.
- The `g` graph: The graph contains a vertex for each route, and an edge for each connection between routes that share a stop. The number of connections is at most `S*K^2` but could be less if not all buses are fully connected. Thus, this adds `O(V+E)` space.
- The `vis` set and `q` deque: These could contain each route once, resulting in `O(R)` space for `vis` and `O(R)` for `q` at worst.

The overall space complexity is: `O(R*S + S*K + V+E)`.