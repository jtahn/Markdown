[11. Container With Most Water](https://leetcode.com/problems/container-with-most-water/)

```
class Solution:
    def maxArea(self, height: List[int]) -> int:
        
```

# Description
You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`.

Find two lines that together with the x-axis form a container, such that the container contains the most water.

Return _the maximum amount of water a container can store_.

**Notice** that you may not slant the container.

**Example 1:**  
![](../!assets/attachments/Pasted%20image%2020240224215140.png)  
**Input:** `height = [1,8,6,2,5,4,8,3,7]`  
**Output:** `49`  
**Explanation:** The above vertical lines are represented by array `[1,8,6,2,5,4,8,3,7]`. In this case, the max area of water (blue section) the container can contain is 49.  

**Example 2:**  
**Input:** `height = [1,1]`  
**Output:** `1`  

**Constraints:**
- `n == height.length`
- `2 <= n <= 10^5`
- `0 <= height[i] <= 10^4`

---

# todo

## self
- defining 'full iteration method' for second approach, isnt perfect yet

## move to blurb: fundy
- literature review:
	- surely someone on leetcode forums/etc, has some discussion about how 2-pointer is just about:
		- picking a 'good' way to iterate
		- then skipping iterations
	- (similar to those ‘comprehensive templates’ about binary search or DP)

## move to 'revising efficiently'
- 'references' heading will list (possibly undiscovered) problems want to cite
	- under each heading, put the discussion that i want to occur in that fundy
		- future revisions (ie on main computer, where it's more convenient) will move it
	- also put the 'summary' that I plan to keep in this writeup (ie brief description of why we cite that fundy)



# References
## solution is extrema over search space
- maybe a math analogy is helpful here:
	- in intro math major courses (ie calc), the way you typically think of computing solutions: a sequence of arithmetic operations
	- but in later courses, you're introduced to the following technique:
		- (when we never actually have to explicitly compute/construct the solution)
		- define a set/space of things
		- define what a max/min element is
		- show that any extrema, if it exists, is a solution
		- show existence of that extrema
	- seems a LOT of leetcode problems: exact same philosophy as the 'extrema' approach
	- but the beauty of cs/swe:
		- (bc finite search space) existence of an extrema is free
		- (bc computers) we can just compute the keys of every element
	- it seems this is one of the standard ways to 'think like a programmer'
		- also imo its just very beautiful, bc often it's far more straightforward to figure out how to interpret the solution as an extrema over a set
- !!!!this fundy should have the discussion about why 'existence of extrema/solution' is free
	- (aka bc finite search space)
	- i had this somewhere, I think in [techniques, fundamental](../Blurbs/techniques,%20fundamental.md)


## 2 pointer is about skipping iterations




# Results

## skip iterations by changing the order
- just as important as 'why' you can skip iterations:
	- figuring out the 'global way' to iterate
	- ie 'how should we iterate'
- ie 'certain ways of iterating will let you skip iterations'
- this problem:
	- iterate same thing as brute force, but in a different order
- compare with other problems:
	- iterate over something completely different (ie flipping problem)

# Abstract
- largest 'area' generated by 2 entries (not limited by intermediate entries)



# Approaches
## (global prelims)
- for any pair of heights, the area is based on the smaller of the heights
	- so the area formula is...
- brute force:
	- iterate over all pairs and compute area
	- solution is extrema



## for each start; for each width
- implementations
	- brute force

```
# brute force
# time: O(n^2)
# space: O(1)


def

		- i from 0 to n
		- j from i+1 to n






```


## for each width; for each start
- implementations
	- brute force
	- 2 pointer

```
# brute force


(todo)



# 2 pointer

class Solution:
    def maxArea(self, height: List[int]) -> int:
        l, r = 0, len(height) - 1
        res = 0

        while l < r:
            res = max(res, min(height[l], height[r]) * (r - l))
            if height[l] < height[r]:
                l += 1
            elif height[r] <= height[l]:
                r -= 1
            
        return res
```


### brute force
- iterate as follows:
	- loop over containers widths (in decreasing order)
		- ie start with widest width: aka max width n


### 2 pointer
- we can skip iterations
	- inductive argument
	- say the iterations we have left are within `[L,R]`
	- after you check widest container:
		- wlog, say left wall was the smaller:
			- then we can skip all smaller width containers that share same left wall
			- why: it's the explanation already below, in the "two-pointer" heading
			- so our search space is now just: `[L+1, R]`
- so now we see why 2-pointer is implemented that way

- importantly, area of container is limited by the smaller of the heights
	- if you shrink (ie decrease width) from one of the ends, then the area can only increase if the smaller end is replaced by a larger end


- observation
	- area generated by the `ith` and `jth` lines is:
		- width times height
		- width is `j-i`
		- height is `min(height[i], height[j])`
- strategy
	- summary
		- start with the widest possible container; iteratively narrow the container by shrinking it on the side with the shorter line (bc that's the only way the area can increase, given the shorter width)
	- variables
		- maintain left and right pointers corresp to left and right line of the container
		- keep track of largest area found so far
	- start with widest container (ie using first and last line)
	- iterate
		- the pointer corresp to the smaller height: move it inward
		- compute area, check if it is a new max
- complexity
	- O(n) time
	- O(1) space
- optimizations
	- when we move the shorter pointer (aka the min of the two pointers): keep incrementing it until it hits a taller value than the og value it was at (bc if its not strictly taller, then alrdy know area will be strictly smaller)
- IMPORTANT: why 'eliminated states' had no potential to be a max

![](../!assets/attachments/Pasted%20image%2020240226004633.png)
