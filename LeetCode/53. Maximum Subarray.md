[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)

```
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        
```

Given an integer array `nums`, find the subarray with the largest sum, and return _its sum_.
A subarray is a contiguous non-empty sequence of elements within an array.

**Example 1:**  
**Input:** `nums = [-2,1,-3,4,-1,2,1,-5,4]`  
**Output:** `6`  
**Explanation:** `The subarray [4,-1,2,1] has the largest sum 6.`  

**Example 2:**  
**Input:** `nums = [1]`  
**Output:** `1`  
**Explanation:** `The subarray [1] has the largest sum 1.`  

**Example 3:**  
**Input:** `nums = [5,4,-1,7,8]`  
**Output:** `23`  
**Explanation:** `The subarray [5,4,-1,7,8] has the largest sum 23.`  

**Constraints:**
- $1 \leq \texttt{nums.length} \leq 10^5$
- $-10^4 \leq \texttt{nums[i]} \leq 10^4$

**Follow up:** If you have figured out the `O(n)` solution, try coding another solution using the **divide and conquer** approach, which is more subtle.

---
# Brute force

- check every sub-array; count $\binom{n}{2} + n =O(n^2)$
	- subarray corresp to its endpoints; which corresp pair of indices
		- $\binom{n}{2}$ combos of 2 distinct indices
		- $n$ 'combos' of 2 same indices; aka 1 element subarray
- complexity
	- $O(n^3)$ time
		- for each sub-array, takes O(n) to compute sum
	- $O(1)$ space


# Dynamic programming
```
def maxSubArray(self, nums: List[int]) -> int:
	dp = [0]*len(nums)
	for i,num in enumerate(nums):
		dp[i] = num + max(dp[i-1], 0)
	return max(dp)
```

- observation 1
	- solution on `nums[0:j]` is max of:  
		- solution on `nums[0:j-1]`  
		- max over subarrays of the form `nums[i:j]`
			- i.e. with right endpoint `j`
- observation 2
	- max right subarray sum on `nums[0:j]` is sum of `nums[j]` with max of:  
		- `0`  
		- max right subarray sum on `nums[0:j-1]` 
- observation
	- the max subarray ending at `i` is either:
		1. itself
		2. appending it to the max subarray ending at `i-1`
- strategy
	- fill out an array `dp` where `dp[i]` is max sum for subarrays with right endpoint `i`
		- if `dp[i-1]` is negative, then we should the the best sum ending at `i` is just the element itself
			- ie start a new subarray
	- then return the max of `dp`
- complexity
	- $O(n)$ time
	- $O(n)$ space


# Kadane's
```
def maxSubArray(self, nums: List[int]) -> int:
    max_right_sum_seen = -math.inf
    max_sum_seen = -math.inf
    for num in nums:
        max_right_sum_seen = num + max(0, max_right_sum_seen)
        max_sum_seen = max(max_sum_seen, max_right_sum_seen)
    return max_sum_seen
```

- observations
	- you don't need the array `dp` from the DP solution
		- `dp[i]` only needs `dp[i-1]`
		- `max(dp)` can be computed inside the loop: since max subarray over `nums[:i]` is either
			- max subarray over `nums[:i-1]`
			- `dp[i]` (max subarray ending at `i`)
- strategy
	- loop through array, using variables to track/update:
		- "max subarray sum"
		- "max right subarray sum" (subarray with right endpoint same as current 'full' array wrt iteration step)  
			- max subarray in `[0:j]` is any subarray inside it; but max right subarray in `[0:j]` means subarrays with index range of the form `[i:j]` 
- complexity
	- O(n) time
		- traversed `nums` once
	- $O(1)$ space
- note
	- this is kadane's algo
	- this algo can be modified to allow empty subarrays
		- something like (todo: confirm this): just have a conditional at the end that returns an empty subarray if the sentinel value (ie `-math.inf`) was the best sum found


# (todo) Divide and conquer

![](../!assets/attachments/Pasted%20image%2020240315025546.png)



![](../!assets/attachments/Pasted%20image%2020240226125754.png)

![](../!assets/attachments/Pasted%20image%2020240226125748.png)

![](../!assets/attachments/Pasted%20image%2020240226125742.png)






Time Complexity : O(NlogN), One linear scans of length N and Each recursive call to performs two recursive calls on subslices of size N/2. Therefore, the time complexity of the divide & conquer approach can be represented by the following recurrence relation: T(N)=2T(N/2)+N. Where N is the size of the Array(nums).

Space Complexity : O(logN), Recursion Stack Space. 

![](../!assets/attachments/Pasted%20image%2020240224145207.png)







![](../!assets/attachments/Pasted%20image%2020240224144208.png)
![](../!assets/attachments/Pasted%20image%2020240224144309.png)

![](../!assets/attachments/Pasted%20image%2020240224144245.png)




![](../!assets/attachments/Pasted%20image%2020240224144507.png)

![](../!assets/attachments/Pasted%20image%2020240224144824.png)



![](../!assets/attachments/Pasted%20image%2020240224145021.png)
![](../!assets/attachments/Pasted%20image%2020240224145029.png)


![](../!assets/attachments/Pasted%20image%2020240224145337.png)


also see:
https://leetcode.com/problems/maximum-subarray/solutions/561773/Divide-and-conquer-solution/

## optimized divide and conquer?
![](../!assets/attachments/Pasted%20image%2020240226130133.png)
![](../!assets/attachments/Pasted%20image%2020240226130143.png)