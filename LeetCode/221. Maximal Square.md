[221. Maximal Square](https://leetcode.com/problems/maximal-square/)

```python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        
```

# Description

Given an `m x n` binary `matrix` filled with `0`'s and `1`'s, _find the largest square containing only_ `1`'s _and return its area_.

**Example 1:**  
![](!assets/attachments/Pasted%20image%2020240420011649.png)  
**Input:** `matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]`  
**Output:** `4`  

**Example 2:**  
![](!assets/attachments/Pasted%20image%2020240420011658.png)  
**Input:** `matrix = [["0","1"],["1","0"]]`  
**Output:** `1`  

**Example 3:**  
**Input:** `matrix = [["0"]]`  
**Output:** `0`  

**Constraints:**
- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 300`
- `matrix[i][j]` is `'0'` or `'1'`.

---

# todo


#/move 
- iirc i had trouble cleanly explaining [[84. Largest Rectangle in Histogram]]
	- check out tuf https://www.youtube.com/watch?v=X0X6G-eWgQ8



#/fundy 

- do https://leetcode.com/problems/maximal-rectangle/description/
	- apparently the 'small' change will completely change the approach
	- everyone seems to say this requires 'histogram' solution
		- tuf https://www.youtube.com/watch?v=tOylVCugy9k
		- https://algo.monster/liteproblems/85
	- oh the histogram solution makes total sense
		- my issue is...how do you even come up with this lmao
		- actually, i think this is doable...should just be another polya variant
			- aka practice with figuring out how to define local solutions
			- the difficulty here:
				- instead of local solution at each entry
				- it's like local solution on each row
					- largest rectangle that has a base on this row


	- how to even figure out this strat?
		- step 1: run through a similar 'dp inspo' like in 221, and realize it won't work bc no useful subproblem relations
		- step 2: somehow realize i should leverage histograms...
			- 
		


#/fundy
- more pracctice
	- https://leetcode.com/problems/count-square-submatrices-with-all-ones/
		- tuf https://www.youtube.com/watch?v=auS1fynpnjo



#/meta 
- i need to find the popular chinese forums for cprog discussion...i suspect they might be the best


#/strats 
- some kind of stack solution?
	- https://leetcode.com/problems/maximal-square/solutions/3621258/dp-and-stack/
	- likely uses similar observations as [[84. Largest Rectangle in Histogram]]


# References


## #debug/input_types
- common error here is not realizing:
	- input is matrix of strings, not integers


## #polya/elt_is_boundary
- (figure out correct jargon and clean explanation for this)
- seems a common pattern:
	- given a problem where:
		- you're searching for some kind of 'best cover' (ie interval or square, etc)
	- this is an 'extrema' problem, and so common approach is then: #problem_solving/solution_is_extreme_value 
	- so now: how to assign a value/candidate to each element?
	- well if the candidate/value is supposed to be a 'cover'...then see if you can have this element be a 'well-defined boundary' for the cover
		- and so then you associate the 'best possible cover where this elt is the well-defined boundary'
	- ie for intervals, this is an 'endpoint'
		- ie [[632. Smallest Range Covering Elements from K Lists]]
- for squares (ie here):
	- try a corner
	- ie not 'any elt on boundary'
		- this is what i'm vaguely trying to ignore when i say 'well-defined boundary'
	- i think basically: try to satsfy property where like:
		- this elt is the only elt that is the 'well-defined boundary' for that cover
		- ie every square has exactly 1 bottom-right corner
			- versus: squares have multiple corners; and even more perimeter/side elts
		- maybe the idea/jargon is #polya/representative
			- if i give you a square, then there is a well-defined bottom-right corner
			- so now: for every elt: find the largest valid square where it is the representative
			- and then: we maximize over what the elts compute
- ok so step 1 of this problem:
	- (and seems very natural tbh)
	- it asks for a 'max' thing
	- so understand/figure out how to equate solution to:
		- max over  local solutions generated by each elt
		- where 'local solution' is: max of solutions where this elt is representative
	- !!!! and this then lets you use 'paradigms':
		- bc once you phrase the problem like this:
			- you've turned this into an iteration problem
				- !!! you've phrased this problem in a way where you now think about:
					- how are subproblems related
					- how should you iterate
			- and then this lets you figure out what paradigms you should use
	- !!! i suspect this needs to be one of the most fundamental polya subtags
		- global solution = max of local solutions
		- and then this problem is specifically: one of the ways you define a local solution
			- ie representative
			- and more specifically: for intervals in 1d/2d/nd:
				- maybe the standard choice will be: pick a specific 'corner' elt as a representative
					- what is the 'nd' math jargon for a 'corner'?
					- (what was the 'nd' math jargon for interval/rectangles/etc)



## #dynamic_programming 

- given the 'polya' observations above, lets look at how local solutions are related
	- ie subproblem relations
- how to determine subproblem relations
	- (imo: it's important to understand/highlight: what about 'square' allows us to have such simple relations)
		- bc for rectangles, we have to use a completely different approach
		- square = very strong structure restrictions
		- tbh...idk if there's any abstraction/fundy here...might just be 'adhoc'
	- !!! actually: probly the better way to do this:
		- in 2d, there are a few standard 'subproblem relationship' structures
			- this one is like: look at the previous step along each axis and diagonal
			- other are like: previous step along each axis
			- and there's probly a couple others
				- similar to dpv, when they gave common subproblem setups when working with 1 or 2 vectors
		- and so: just consider each of the standard relationship structures, and see if they work
		 - and for any 'leetcode problem that a company would ask', they likely just fit one of these structures
- once you understand the subproblem relations
	- it's very standard 2d dp with standard 1d optimization


- overview
	- https://algo.monster/liteproblems/221
	- https://leetcode.com/problems/maximal-square/solutions/600149/python-thinking-process-diagrams-dp-approach/
- space optimizations
	- https://leetcode.com/problems/maximal-square/solutions/61803/c-space-optimized-dp/
	- https://leetcode.com/problems/maximal-square/solutions/1632376/c-python-6-simple-solution-w-explanation-optimizations-from-brute-force-to-dp/


- picture proof for subproblems:
	- ![[../!assets/attachments/Pasted image 20240526190212.png]]
- 

# Strategies

## 2d dp

```python
# bottom-up
# https://algo.monster/liteproblems/221

# top-down (needcode repo)
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        ROWS, COLS = len(matrix), len(matrix[0])
        cache = {}  # map each (r, c) -> maxLength of square

        def helper(r, c):
            if r >= ROWS or c >= COLS:
                return 0

            if (r, c) not in cache:
                down = helper(r + 1, c)
                right = helper(r, c + 1)
                diag = helper(r + 1, c + 1)

                cache[(r, c)] = 0
                if matrix[r][c] == "1":
                    cache[(r, c)] = 1 + min(down, right, diag)
            return cache[(r, c)]

        helper(0, 0)
        return max(cache.values()) ** 2

```


## 1d dp

