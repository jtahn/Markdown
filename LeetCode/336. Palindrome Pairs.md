[336. Palindrome Pairs](https://leetcode.com/problems/palindrome-pairs/)

```python
class Solution:
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        
```

# Description

You are given a **0-indexed** array of **unique** strings `words`.

A **palindrome pair** is a pair of integers `(i, j)` such that:
- `0 <= i, j < words.length`,
- `i != j`, and
- `words[i] + words[j]` (the concatenation of the two strings) is a palindrome. A **palindrome** is a string that reads the same forward and backward.

Return _an array of all the **palindrome pairs** of_ `words`.

You must write an algorithm with `O(sum of words[i].length)` runtime complexity.

**Example 1:**  
**Input:** `words = ["abcd","dcba","lls","s","sssll"]`  
**Output:** `[[0,1],[1,0],[3,2],[2,4]]`  
**Explanation:** The palindromes are `["abcddcba","dcbaabcd","slls","llssssll"]`  

**Example 2:**  
**Input:** `words = ["bat","tab","cat"]`  
**Output:** `[[0,1],[1,0]]`  
**Explanation:** The palindromes are `["battab","tabbat"]`  

**Example 3:**  
**Input:** `words = ["a",""]`  
**Output:** `[[0,1],[1,0]]`  
**Explanation:** The palindromes are `["a","a"]`  

**Constraints:**
- `1 <= words.length <= 5000`
- `0 <= words[i].length <= 300`
- `words[i]` consists of lowercase English letters.

---


# todo

#/strats 
- seems there are likely more optimal solutions:
	- trie
	- DP
	- bitmasking

- if the trie solution is what i think it is…then hashing likely is still worth keeping, bc it should have far better space complexity
	- ie i suspect trie will essentially store every prefix (and/or suffix)
	- similarly, i bet ‘dp’ will have terrible space complexity


#/strats 
- brute force is: for each pair of strings, concatenate and check if it’s a palindrome
- i wonder if each major strat is like a different interpretation of how to optimize from brute force
	- hashmap
		- tbh i’m not sure what this is optimizing
			- it’s true that there are problmes where: ‘check if valid inverse exists among stuff we’ve iterated over’ is more efficient than ‘check pairs and see if its valid’
			- but the big issue is that: each element requires a bunch of ‘inverse’ checks, not just one
			- and isn’t ‘reversing’ a string is theoretically same complexity as checking for a palindrome
				- bc both involve linear scans?
	- trie
		- seems like this approach actually does optimize…bc it optimizes both:
			- ‘check if palindrome’
			- ‘check if exists over stuff we’ve iterated over’


#/strats 
- hashing
	- for each word:
		- for each prefix and suffix:
			- check if it matches with any word we’ve already visited
- trie
	- one strat seems to be:
		- first build the entire suffix tree
		- for each word:
			- for each prefix:
				- check if it matches with any suffix
	- this suggests: maybe there is room for a time optimization, by only checking over stuff we’ve visited?
		- however: then this increases space, bc now, we probly need a tree for both prefix and  suffix
- !! so it seems there’s like multiple optimizations going on here:
	- first is the fact that trie is better than hashmap, bc it prunes a search far earlier
		- ie no point checking larger prefixes, if we already know it can’t be built
	- second is:
		- if we build our structure as we go along:
			- aka only check among visited
			- then we need to run checks on both prefixes and suffixes
		- but if we build structure ahead of time:
			- we could just only run checks on prefixes
	- !!! so this is an example where, if the ‘pairing/inversion’: if order matters:
		- (order matters here, bc if input is `[a, a]`, then both 01 and 10 are considered distinct palindrome constructions)
		- then ‘only checking over visited’ will increase how much code you write, bc now you have to write a subroutine for both options/orders
		- i feel like complexity of both is the same though…’only checking over visited’ will probably have a better constant? but now you have to write like double the code
			- wait actually…i don’t think it has a better constant
			- bc ‘only checking over visited’ still ends up creating the full structure


- the big reason why trie is more attractive than hashmap:
	- when we check existence of a prefix/suffix:
		- if it dne in trie, then we know there’s no point checking larger prefix/suffix, bc they don’t exist either
		- but hashmap does not allow for this pruning step
- !! so the optimizations really have nothing to do with: ‘checking if it’s a palindrome’
	- well they do, but this basically already built into the fact that you gradually increase the prefix
		- increasing a prefix/suffix is O(1)
		- and then you just check existence for the match, this is O(1) for both trie and hashmap
	- however this ‘optimization’ comes at a heavy cost:
		- bc in brute force, you never had to consider prefix/suffix
		- but now for these ‘optimized’ solutions, you do have to consider every prefix/suffix
		- actually these ‘optimized’ solutions are arguably worse, bc you also need to do a palindrome check on the rest of the word, ie the ‘mid’ part
- ok so honestly…idk if the hashmap approach is even a good approach tbh…
	- aka this should really be considered a pure ‘trie’ problem
- surely there’s some kind of optimization for these ‘optimized’ approaches, for the part where you check if ‘mid’ is a palindrome?
	- ehh i doubt it…the problem is that the substring/mid palindrome has to start at an endpoint (ie its a prefix/suffix), and so i dont think there’s an efficient way to do this
		- ie can’t use manacher’s, aka it’s not like [[647. Palindromic Substrings]]
			- there, we had optimizations bc the palindromes could be anywhere in the string
				- aka that’s why, we do it by iterating over possible ‘centers’
	- and imo storing these computations (ie dp)…there’s no benefit
		- bc the only time you do a mid check on a substring, is when its full string is the current iteration
			- aka for each prefix/suffix of a string, you only do a ‘check if mid is palindrome’ only once



#/strats 
interesting comment by czheng in the discussion section of this problem:
https://leetcode.com/problems/palindrome-pairs/description/comments/1566204


The time complexity of the official solutions will be much worse than simple brute force in some edge test cases, most likely will trigger TLE. Consider the following test case:
```
["aaaaa...(repeat 149 times)**bc**aaaaa(repeat 149 times again)", "aaaaa...(repeat 149 times)**bb**aaaaa(repeat 149 times again)",""]
```

Note this test case has only 3 elements, where the first one is not a palindrome, the second one is a very long palindrome, and the third one is empty (thus is also a palindrome, and will combine with the second one to form a valid output). The answer should be `[[1,2],[2,1]]`.

In brute force the time complexity is O(n^2 x k) = O(3^2 x 300) = O(2700). But in both hashmap and trie solution the time complexity is O(n x k^2) = O(3 x 300^2) = O(270000), which is 100 times of the brute force solution.

Now this single case may be ok for the timing of the online judge. But in an extreme scenario if there are 1000 such test cases input to the program, the total runtime will be significantly increased, most likely will trigger TLE.

Another interesting thing is it seems C++ is the primary victim of such timing judge. Sometimes if we just write a quick but dirty code without recycling the resources (e.g. the new TrieNode created during the trie building), the timing will be ok. But if we explicitly record all allocated resource and manually free them at the end of the program, the timing will exceed the limit of the online judge. This sounds very unreasonable -- the timing is too tight which discourages programmers to properly recycle the allocated resources. This maybe fine for Java but will be a disaster for C++ in realworld.

---




# References


## #hashing/collisions 
- i should probably point out that a classic (or the basic) use case of this technique is when we have:
	- a list of elements
	- some kind of function such that
		- f(x) = y IFF f(y) = f(x)
		- aka defines a unique ‘pair’ for each element
	- a question that is of any of the following forms:
		- does a pair exist
		- count pairs
- and so then the classic strat is:
	- iterate over elements once
	- as we iterate: store visited stuff in hashmap
	- so then future elements: can efficiently determine if it’s “pair” exists


- this problem is a variant + significantly increases the difficulty bc:
	- each element has multiple collision checks
		- there’s basically only 1 way to do this: essentially
			- for each word: for each prefix and suffix:
				- check collisions on the reverse:
				- (and other conditions)
			- observe that this space complexity won’t be that bad, bc the above strat only requires storing the whole word as a collision
				- ie, we don’t store all prefixes/suffixes as collisions
					- importantly: this wouldn’t actually work or make any sense
					- bc this means your main routine is like: you’re given a,
					- and you want to figure out if a word p+ra exists where p is a palindrome and ra is reverse of a
					- so this makes zero sense, bc how could you ever search for p+ra efficiently




## #interview/clarify

- this seems like another example where asking questions is important
- the constraints seem allow empty string
- observe the constraints do not allow an ‘empty string’
	- if this was allowed, it would add noticeable more work to the problem
- wait i’m so confused…one of the test cases has an empty string…


# Strategies


## (only) hashmap

- examples
	- https://algo.monster/liteproblems/336

#/code 
- i’m not a fan of the code below
	- imo use better variables names…particuarly, imo i think i should let `mid` be substring where i run a palindrome check?
	- ehh actually, the code below is honestly decent, once you understand the strat..i think it’s enough to have some comments be like:
		- `# check palindrome a + b + ra`
		- and `# check palindrome rb + a + b`


```python
# leetcode.ca
class Solution:
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        d = {w: i for i, w in enumerate(words)}
        ans = []
        for i, w in enumerate(words):
            for j in range(len(w) + 1):
                a, b = w[:j], w[j:]
                ra, rb = a[::-1], b[::-1]
                if ra in d and d[ra] != i and b == rb:
                    ans.append([i, d[ra]])
                if j and rb in d and d[rb] != i and a == ra:
                    ans.append([d[rb], i])
        return ans
```
