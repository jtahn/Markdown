https://leetcode.com/problems/balanced-binary-tree/

Given a binary tree, determine if it is **height-balanced**.

A **height-balanced** binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.

**Example 1:**  
![](../!assets/attachments/Pasted%20image%2020240224220659.png)  
**Input:** `root = [3,9,20,null,null,15,7]`  
**Output:** `true`

**Example 2:**  
![](../!assets/attachments/Pasted%20image%2020240224220708.png)  
**Input:** `root = [1,2,2,3,3,null,null,4,4]`  
**Output:** `false`

**Example 3:**  
**Input:** `root = []`  
**Output:** `true`

**Constraints:**
- The number of nodes in the tree is in the range `[0, 5000]`.
- `-10^4 <= Node.val <= 10^4`

---

# Brute force
- strategy
	- iterate over the nodes:
		- run a routine that checks whether its subtrees are balanced
			- (would be very similar to routine described in the post-order solution below)
- complexity
	- O(N^2) time
	- O(H) space (where H is height of the tree)
		- since binary tree..then isn't H = log N?
		- actually maybe not, bc it's not assumed to be balanced



# DFS / post order traversal / bottom-up
- observation
	- brute force does a lot of redundant work; because if a node is unbalanced, then so are all its parents
	- so just traverse bottom-up
- note
	- traversal can be done recursively, or iteratively/manually via your own stack
- strategy
	- each node receives/asks for height/depth from it's children.
	- one of the following will happen:
		- a child is already unbalanced (returned -1), so it just returns -1 as well
		- the children are unbalanced (heights diff by more than 1), so it returns -1
		- the children are balanced. so compute it's height by adding 1 to max height of children

![](../!assets/attachments/Pasted%20image%2020240224221009.png)



## iterative
![](../!assets/attachments/Pasted%20image%2020240224221025.png)


## Recursive

```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def dfs(root):
            if not root:
                return [True, 0]

            left, right = dfs(root.left), dfs(root.right)
            balanced = left[0] and right[0] and abs(left[1] - right[1]) <= 1
            return [balanced, 1 + max(left[1], right[1])]

        return dfs(root)[0]
```

- you have to write a recursive function inside the main function
- bc the recursive function returns integer values
- the wrapper main function returns a bool by comparing it to -1 (the integer we use to represent the unbalanced condition)


![](../!assets/attachments/Pasted%20image%2020240224221108.png)

