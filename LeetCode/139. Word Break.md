[139. Word Break](https://leetcode.com/problems/word-break/)

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        
```

# Description

Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.

**Note** that the same word in the dictionary may be reused multiple times in the segmentation.

**Example 1:**  
**Input:** `s = "leetcode", wordDict = ["leet","code"]`  
**Output:** `true`  
**Explanation:** Return `true` because `"leetcode"` can be segmented as `"leet code"`.

**Example 2:**  
**Input:** `s = "applepenapple", wordDict = ["apple","pen"]`  
**Output:** `true`
**Explanation:** Return `true` because `"applepenapple"` can be segmented as `"apple pen apple"`.  
Note that you are allowed to reuse a dictionary word.

**Example 3:**  
**Input:** `s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]`  
**Output:** `false`

**Constraints:**
- `1 <= s.length <= 300`
- `1 <= wordDict.length <= 1000`
- `1 <= wordDict[i].length <= 20`
- `s` and `wordDict[i]` consist of only lowercase English letters.
- All the strings of `wordDict` are **unique**.

---


# References

## #dynamic_programming 




#/research 
- again here..why is neetcode iterating backwards?
	- if you can also iterate forwards...then try to also find leetcode problems with dp solutions where it actually matters which direction you iterate (and try to find examples for both directions; ie a problem where you have to iterate forwards for strictly best complexity, and another problem where you need backwards)



# Results

## #/tbd 

- (there is a generalization here, but imo figure it out later...will probly become obvious when i see more examples of it)
- observe 2 ways to check for 'substring at beginning of word' in dict:
	- for each substring `s[:k]`, check if it's in dict
	- for each item in dict, check if it matches the beginning of `s`
- and the choice of which to do should theoretically depend on sizes of `s` and `dict`
	- (tho...maybe python implementation matters here?)
	- aka if `s` is much larger (as is the case here), then maybe you should iterate through dict?
	- if `dict` is much larger, then you should iterate through 'left substrings' of `s`



## #python/any
- take a look at algomonster code



# Strategies



## dynamic programming
- implementations
	- outer backwards, inner over dict
		- neetcode
	- outer forwards, inner over substrings
		- https://algo.monster/liteproblems/139
```python
# outer backwards; inner over dict
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:

        dp = [False] * (len(s) + 1)
        dp[len(s)] = True

        for i in range(len(s) - 1, -1, -1):
            for w in wordDict:
                if (i + len(w)) <= len(s) and s[i : i + len(w)] == w:
                    dp[i] = dp[i + len(w)]
                if dp[i]:
                    break

        return dp[0]


# iterate through string
class Solution:
	def

```