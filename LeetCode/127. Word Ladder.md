[127. Word Ladder](https://leetcode.com/problems/word-ladder/)

```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        
```

# Description

A **transformation sequence** from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words `beginWord -> s_1 -> s_2 -> ... -> s_k` such that:

- Every adjacent pair of words differs by a single letter.
- Every `s_i` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.
- `s_k == endWord`

Given two words, `beginWord` and `endWord`, and a dictionary `wordList`, return _the **number of words** in the **shortest transformation sequence** from_ `beginWord` _to_ `endWord`_, or_ `0` _if no such sequence exists._

**Example 1:**  
**Input:** `beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]`  
**Output:** `5`  
**Explanation:** One shortest transformation sequence is "hit" -> "hot" -> "dot" -> "dog" -> cog", which is 5 words long.

**Example 2:**  
**Input:** `beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]`  
**Output:** `0`
**Explanation:** The endWord "cog" is not in wordList, therefore there is no valid transformation sequence.

**Constraints:**
- `1 <= beginWord.length <= 10`
- `endWord.length == beginWord.length`
- `1 <= wordList.length <= 5000`
- `wordList[i].length == beginWord.length`
- `beginWord`, `endWord`, and `wordList[i]` consist of lowercase English letters.
- `beginWord != endWord`
- All the words in `wordList` are **unique**.

---


# todo
- [[_refs/texts/epi.pdf#page=373&offset=-115,621,0|epi, 19.7 Transform one string to another]]
	- you turn the dictionary into a graph, so vertices are the words, and there's an edge between vertices if the string have one character difference from each other.
	- first routine is just, I guess, creating the graph, or it's like either creating the graph or it's, let me see, I mean the general idea is, this is the graph we have in mind, and then to find it we want to use BFS, because it's shortest path on undirected graph, now let's look at how you actually implement this, because we have the general strategy.

Oh, okay, you never actually create the graph, yeah, all you do is just, the BFS, to find the nodes, you just, yeah, for each character in the string you try every possible letter combination adjustment, and then, yeah, this is BFS for sure.

Yeah, the only issue I have with this is that, I mean, it seems inefficient to find the next valid neighbor nodes for the traversal, but I don't think there's any other way to do this, right, because if you want to make the graph, if you want to legitimately make a graph with pointers to the nodes, while creating this graph you have to do this process anyways, because for each node, how are you going to figure out what to link with it, like you're not going to search the dictionary, because for a big dictionary that's incredibly inefficient, so the way you'd have to do this is either you search through the graph that you've already, you search for the nodes in the graph that you've already created, but that's also inefficient, like as the graph gets bigger, because then at a certain point this is just the size of the dictionary, once most of the words are in there, this is also really inefficient, so the most efficient way is just going to be exactly just for each letter, try one of the alphabets and see if this already exists in the graph, so at this point, I mean, you've already done this, so there's no point in actually making the graph.







# Strategies

```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        if endWord not in wordList:
            return 0

        nei = collections.defaultdict(list)
        wordList.append(beginWord)
        for word in wordList:
            for j in range(len(word)):
                pattern = word[:j] + "*" + word[j + 1 :]
                nei[pattern].append(word)

        visit = set([beginWord])
        q = deque([beginWord])
        res = 1
        while q:
            for i in range(len(q)):
                word = q.popleft()
                if word == endWord:
                    return res
                for j in range(len(word)):
                    pattern = word[:j] + "*" + word[j + 1 :]
                    for neiWord in nei[pattern]:
                        if neiWord not in visit:
                            visit.add(neiWord)
                            q.append(neiWord)
            res += 1
        return 0

```