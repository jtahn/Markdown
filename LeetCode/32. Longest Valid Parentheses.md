[32. Longest Valid Parentheses](https://leetcode.com/problems/longest-valid-parentheses/)

```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        
```

# Description

Given a string containing just the characters `'('` and `')'`, return _the length of the longest valid (well-formed) parentheses substring.

A **substring** is a contiguous **non-empty** sequence of characters within a string.

**Example 1:**  
**Input:** `s = "(()"`  
**Output:** `2`  
**Explanation:** The longest valid parentheses substring is "()".

**Example 2:**  
**Input:** `s = ")()())"`  
**Output:** `4`  
**Explanation:** The longest valid parentheses substring is "()()".

**Example 3:**  
**Input:** `s = ""`  
**Output:** `0`  

**Constraints:**
- `0 <= s.length <= 3 * 10^4`
- `s[i]` is `'('`, or `')'`.

---


# todo

#/workflow 
- in the 'todo list of completeness of writeup':
	- 'checking lc forums' means:
		- going through top description comments
		- going through top lc solution writeups AND comments

#/jargon
- need a tag for:
	- (currently, #dynamic_programming/similar )
	- dp variant where you solve a 'similar' problem g, and then answer is efficient routine over output to similar problem
	- rename this tag to that polya jargon for where you 'solve a similar problem'


#stacks 
- other ppl seem to confirm what i was thinking...stacks are often used in like a few of the same patterns
	- simulation was one of them
		- monotone might be a special case of simulation
		- but it seems it's such a major pattern itself, that maybe it should be it's own subtag...and then just mention that its actually a special case
	- i forget the others, but i had this observation in some of the other stack problems i just did
	- aka...probly have subtags for each of these main patterns



#/problems 
(do these if i haven't yet, and then assign the stack subtags i mentioned above)

Next Greater Element  
Next Smaller Element  
Previous Greater Element  
Previous Smaller Element  
Largest Rectangle in Histogram


# References

## tbd
- apparently not dp:


thx for dp solution but I feel it's manual stack depth counter, rather than dp...


its not dp because there no overlapping subproblems.

'storing stuff' != dp

maybe: if solution is like 'max over dp table' or smthn like that...then it's not dp?
ie dp should always be: solution is 'final entry of table'


---


- define `f[i]` = length of the longest valid substring ending at index `i - 1`
	- answer will be `max(f)`
- conditions:
	- if char at `i - 1` is '('
		- then no valid substring can end with this character
		- so `f[i] = 0`
	- if char at `i - 1` is ')'
		- if char at `i - 2`is '('
			- we have a pair "()"
			- so `f[i] = f[i - 2] + 2`
		- if char at `i - 2` is also ')'
			- then `f[i] = f[i - 1] + 2 + f[i - f[i - 1] - 2]`
			- bc: might be a continuation of a previously started valid string
			- so first check that there's a valid string ending just before the current one (at `i - f[i - 1] - 2`). If there is, and the character at the beginning of this string (at `i - f[i - 1] - 2`) is '(', then the current ')' can close this, forming a new valid string, so we append the lengths: .


we have to look back and check if there's a matching opening parenthesis that can pair with our current one. To find it, we subtract the length of the valid substring ending just before (at `f[i - 1]`) from `i` and go back one more step (hence `i - f[i - 1] - 2`). If we find that there's an opening parenthesis at that position, we can extend the length of the valid substring ending there by adding the length of the valid substring ending at our current position plus 2 for the current pair "()", and also add the value at `f[j - 1]`, where `j` is the index we just found to check availability of a valid opening parenthesis. This step accounts for concatenating a new valid pair to an existing valid substring.

basically this isprobly like the case where we're "closing something that's nested"





## #stacks 
- idea
	- stack that stores the index of the left bracket
	- via stack ops, update the length of the valid bracket substring
- implementation/tricks
	- The bottom element of the stack is initialized to `-1`, which is used to assist in calculating the length of the effective bracket.

- basically:
	- if stack is nonempty, then we have a nonempty valid substring at this point
	- if stack is empty, then nothing valid


- Iterate over the string, and for each character:
    - If it is a left bracket, push the current position onto the stack.
    - If it is a right bracket, popping the top element of the stack indicates that a left bracket is matched.
        - If the stack is empty, it means that the current right bracket cannot be matched, and the current position is pushed into the stack as a new starting point.
        - If the stack is not empty, calculate the length of the current valid bracket substring and update the maximum length.

---

So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.

First, stack push position of each '(', then when we meet ')' I pop stack to find its match'('， place both ')' and '(' as 1 in array

For example, (()()，array should look like[0,1,1,1,1]

Then it is super easy, to find out longest substring that all items are 1 !!!

---

This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.

---


- https://leetcode.com/problems/longest-valid-parentheses/solutions/1139990/longest-valid-parentheses-short-easy-w-explanation-using-stack/
	- maybe #simulation 


# Strategies

## tbd (probly not dp)

- complexity
	- time O(n)
	- space O(n)

```python
class Solution:
2    def longestValidParentheses(self, s: str) -> int:
3        # Get the length of the input string
4        string_length = len(s)
5        # Initialize a DP array with zeros, one extra for the base case
6        dp = [0] * (string_length + 1)
7      
8        # Loop over the characters of string starting from index 1 for convenience
9        for index, char in enumerate(s, 1):
10            # We look for closing parentheses, as they mark possible ends of valid substrings
11            if char == ")":
12                # If the previous char is '(', it's a pair "()"
13                if index > 1 and s[index - 2] == "(":
14                    # Add 2 to the result two positions ago in dp array
15                    dp[index] = dp[index - 2] + 2
16                else:
17                    # Get the index of the potential matching '('
18                    match_index = index - dp[index - 1] - 1
19                    # Make sure match_index is within bounds and check for '('
20                    if match_index > 0 and s[match_index - 1] == "(":
21                        # Add the length of the valid substring ending right before the current one,
22                        # plus two for the '()' just found, plus length of valid substring before the pair
23                        dp[index] = dp[index - 1] + 2 + dp[match_index - 1]
24      
25        # Return the maximum length of valid parentheses found
26        return max(dp)
27

```



oooo interesting trick: #/fundy ?
- seems they prepend with a char so that first entry of dp array is 0
- and so then it means dp array indices match up with string indices
- tho idk...this trick seems fairly limited?
	- aka i should regardless be comfy with 'not matching indices btwn input and dp table'


```python
class Solution:
  def longestValidParentheses(self, s: str) -> int:
    s2 = ')' + s
    # dp[i] := the length of the longest valid parentheses in the substring
    # s2[1..i]
    dp = [0] * len(s2)

    for i in range(1, len(s2)):
      if s2[i] == ')' and s2[i - dp[i - 1] - 1] == '(':
        dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2

    return max(dp)
```


## stack


- complexity
	- time O(n)
	- space O(n)

```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        stack = [-1]
        ans = 0
        for i in range(len(s)):
            if s[i] == '(':
                stack.append(i)
            else:
                stack.pop()
                if not stack:
                    stack.append(i)
                else:
                    ans = max(ans, i - stack[-1])
        return ans
```