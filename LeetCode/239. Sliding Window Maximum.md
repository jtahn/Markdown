[239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)

You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.

Return _the max sliding window_.

**Example 1:**  
**Input:** `nums = [1,3,-1,-3,5,3,6,7], k = 3`  
**Output:** `[3,3,5,5,6,7]`  
**Explanation:**  
```
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       **3**
 1 [3  -1  -3] 5  3  6  7       **3**
 1  3 [-1  -3  5] 3  6  7      ** 5**
 1  3  -1 [-3  5  3] 6  7       **5**
 1  3  -1  -3 [5  3  6] 7       **6**
 1  3  -1  -3  5 [3  6  7]      **7**
```

**Example 2:**  
**Input:** `nums = [1], k = 1`  
**Output:** `[1]`  

**Constraints:**
- `1 <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`
- `1 <= k <= nums.length`

---
# Observation
![](../!assets/attachments/Pasted%20image%2020240306123058.png)


# Brute force
- for each window, compute max in the window
- complexity
	- O(nk) time



# max heap
```
from heapq import *

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        
        H = []
        ans = []
        
        for i in range(k):
            heappush(H,[-nums[i],i])
        
        ans.append(-H[0][0])
        
        for i in range(k,len(nums)):
            heappush(H,[-nums[i],i])
            
            while H and i - H[0][1] >= k:
                heappop(H)
            
            ans.append(-H[0][0])
        
        return ans
```




- if your structure exactly contains elements in the window, then that means every time window shifts, you need to figure out where the left node is
	- (so our structure is size k)
	- max heap is not good for this
		- this is O(k)
	- binary search tree is better for this
	- so that's why observation:
		- maybe allow structure to not exactly contain elements in the window?
			- deque: carry less
			- better max heap: carry more...



- observation
	- issue with heap is that: not rly an efficient way to delete the node that's exiting the window
		- way to get around this: observe we only have to delete the node if it the max, otherwise nbd if it's still there
		- so the solution: store not just the value, but the index: so we can quickly check if max value is outside window
	- note: it is NOT true that search/delete is O(log n), despite 'binary' heap
		- !! binary heap and binary search tree have DIFFERENT inequality relations
			- heap property: parent greater than children
				- this tells you nothing about where your node is
				- literally all it is helpful for is finding the max, that's literally it
			- binary search tree: left child <= parent <= right child
				- this relationship is what leads to O(log n) search/delete
	- without this trick of storing index with value:
		- 
- seems that generally, heaps are assumed to be binary heaps
	- ie python implementation is binary heap
	- wiki says common implementation is binary heap

- implementation
	- the while loop: pops max elements that are invalid; ie index is out of the window
		- index of newest node is `i`
		- max node is `H[0]`
			- so `H[0][1]` is its index in the array
		- so `i - H[0][1] >= k` checks whether the current max value is actually outside the window
		- if so, we pop it
			- and we keep doing this as needed
		- once while loop ends, we know the current heap max is in the window

- complexity
	- time O(n log n)
		- note maxheap has no required max size; it only pops if top is outside bounds, but there's no reason this needs to happen
		- ie we'd get a maxheap with the entire sequence if it is an increasing sequence
			- bc we never need to pop; bc the max is always in the window
		- so worst case assume maxheap is size n
			- in which case, operations are O(log n)
	- space
		- O(n)





# Self-balancing BST
```
class Solution {
    public int[] maxSlidingWindow(int[] arr, int k) {
        int n = arr.length, j = 0;
        int[] ans = new int[n - k + 1];
        TreeMap<Integer, Integer> bst = new TreeMap<>();
        for (int i = 0; i < n; i++) {
            bst.put(arr[i], bst.getOrDefault(arr[i], 0) + 1);
            if (i + 1 >= k) {
                ans[j++] = bst.lastKey(); // return max element in BST
                removeElement(bst, arr[i+1-k]);
            }
        }
        return ans;
    }
    void removeElement(TreeMap<Integer, Integer> bst, int x) {
        bst.put(x, bst.getOrDefault(x, 0) - 1);
        if (bst.get(x) == 0) bst.remove(x);
    }
}
```


note: apparently above only works if the elements in k window are unique as TreeMap is based on Red-Black tree which can't have duplicates

what do you do if duplicates?

- 
- complexity
	- time O(N log k)
		- because each operation of a BST of size k costs O(log k)
	- space O(k)


- basically, this is like a balance btwn 'quickly find max' and 'quickly find node to delete'
	- we sacrifice O(1) computation of max, so that "deleting node" is gauranteed O(log n)



- one bottleneck in brute force, is the computation of the max
	- is there a way to do this faster?
	- ![](../!assets/attachments/Pasted%20image%2020240306154317.png)





# Decreasing deque (best)

![](../!assets/attachments/Pasted%20image%2020240306155844.png)
![](../!assets/attachments/Pasted%20image%2020240306155855.png)
![](../!assets/attachments/Pasted%20image%2020240306155925.png)


```
from collections import deque

"""cleanest"""
class Solution:
    def maxSlidingWindow(self, nums, k):
        deq, n, ans = deque([0]), len(nums), []

        for i in range (n):
            while deq and deq[0] <= i - k:
                deq.popleft()
            while deq and nums[i] >= nums[deq[-1]] :
                deq.pop()
            deq.append(i)
            
            ans.append(nums[deq[0]])
            
        return ans[k-1:]


"""shorter"""
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        q = deque() # stores *indices*
        res = []
        for i, cur in enumerate(nums):
            while q and nums[q[-1]] <= cur:
                q.pop()
            q.append(i)
            # remove first element if it's outside the window
            if q[0] == i - k:
                q.popleft()
            # if window has k elements add to results (first k-1 windows have < k elements because we start from empty window and add 1 element each iteration)
            if i >= k - 1:
                res.append(nums[q[0]])
        return res


""longer"""

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        # Initialize a deque for storing indices of elements
        index_queue = deque()
        # List to store the maximums for each sliding window
        max_values = []
      
        # Iterate over each element, with its index
        for current_index, value in enumerate(nums):
            # If the first element in the queue is outside the current window, remove it
            if index_queue and current_index - k + 1 > index_queue[0]:
                index_queue.popleft()
          
            # Remove elements from the back of the queue if they are smaller than
            # or equal to the current element since they will not be needed anymore
            while index_queue and nums[index_queue[-1]] <= value:
                index_queue.pop()
          
            # Add the current index to the queue
            index_queue.append(current_index)
          
            # If we have reached or passed the first complete window, record the maximum
            if current_index >= k - 1:
                max_values.append(nums[index_queue[0]])
      
        # Return the list of maximums
        return max_values
```


![](../!assets/attachments/Pasted%20image%2020240306154346.png)


- jargon that is typically used for this
	- monotonic (increasing) queue
	- decreasing deque
		- a deque is a data structure that allows insertion and deletion from both the front and the back in `O(1)` time complexity
- Sliding window minimum/maximum = monotonic queue
	- The key why monotonic deque works is it stores both magnitude and position information. From head to tail, the elements get smaller and further to the right of the array.
- monotonic queue involves 3 operations
	- pop; aka discard left pointer
		- the only index that might corresp to index of left pointer, is exactly the left-most thing in the deque
			- so we check if its the left pointer; if not, there's nothing to discard/pop
	- push: add right pointer
		- not only do we add it; we also discard non maxes in the window
			- aka anything in the deque that is smaller than the right pointer
		- ie we also discard stuff that is smaller
	- peek
		- aka tell us the max
		- deque ordered by max
		- which means, left pointer is also the index of max in the window
	- apparently: using a monotonic queue has a very established sequence for each iteration: can either:
		- push,peek,pop
		- pop,push,peek
		- pop,
		- they're all the same..only diff, slight modification to stuff before and after the loop...
- complexity
	- O(n) time
		- since each element is processed (add/remove) at most twice.
		-  The algorithm is amortized O(n) as each element is put and polled once.
		- each element in the original array can only be pushed into and popped out of the deque only once.
	- O(k) space


![](../!assets/attachments/Pasted%20image%2020240306152041.png)




![](../!assets/attachments/Pasted%20image%2020240306151201.png)



---

Keep indexes of good candidates in deque d. The indexes in d are from the current window, they're increasing, and their corresponding nums are decreasing. Then the first deque element is the index of the largest window value.

---

In the `Deque`, we add and remove indices.

Basically, for each element `nums[i]` in the array that we are about to insert, we first check whether the leftmost index in the sliding window is out of bound. If so, we remove it by `pollFirst()` in constant time.

Then we continuously remove the rightmost indices if their corresponding elements are less than `nums[i]` (the element we are about to insert). The idea is that the elements that are less than the element we'll insert won't have any contributions to the maximum element of the sliding window. So it is safe to remove them.

After removal `pollLast()` and insertion `offerLast(i)` (the element `nums[i]`), we can say that the leftmost element in the window is maximum.

(translate above java to python)
![](../!assets/attachments/Pasted%20image%2020240306145953.png)



---
![](../!assets/attachments/Pasted%20image%2020240306155746.png)

---

![](../!assets/attachments/Pasted%20image%2020240306121916.png)
```
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        # initialize variables, q, which is our double ended monotonic decreasing queue.
        # max_window, which is our output for the question, and l which is the pointer for
        # the left side of our window.
        # Note we will be adding tuples to our deque for this question in the form,
        # (x,y) where the first value x, will be the index inside nums, and the
        # second value y, will be the value of the number at nums(x)
        q = deque([])
        max_window = []
        l = 0
        # loop through the numbers in nums, tracking our right pointer of our window,
        # r, and the incoming number, num.
        for r, num in enumerate(nums):
            # While the queue exists, and incoming number is > than the right most
            # side. Note: We need to check that the q exists to prevent popping from
            # and empty q.
            while q and q[-1][1] < num:
                # pop the smaller number
                q.pop()
            # Add our incoming number to our monotonic queue.
            q.append((r, num))
            # Check left side is within window, and hasn't left it yet.
            if l > q[0][0]:
                # if so, we remove it from our queue.
                q.popleft()
            # Add the largest number in our window to the output array. Since our
            # queue is a monotonic decreasing queue, the largest number will always
            # be on the left side, and since we already popped out the any numbers
            # on the left that aren't in our window, this will be the largest number
            # currently inside our window.
            if r+1 >= k:
                max_window.append(q[0][1])
                # move the pointer for the left side of our window forward.
                l += 1
        # Return the output of our algorithm, the maximum sliding window.
        return max_window
                
```


---

![](../!assets/attachments/Pasted%20image%2020240306122028.png)

![](../!assets/attachments/Pasted%20image%2020240306122100.png)
![](../!assets/attachments/Pasted%20image%2020240306122140.png)






# Dynamic programming (also best)


![](../!assets/attachments/Pasted%20image%2020240306204950.png)
![](../!assets/attachments/Pasted%20image%2020240306205106.png)


![](../!assets/attachments/Pasted%20image%2020240306205234.png)


![](../!assets/attachments/Pasted%20image%2020240306205005.png)

![](../!assets/attachments/Pasted%20image%2020240306205158.png)

![](../!assets/attachments/Pasted%20image%2020240306205258.png)


![](../!assets/attachments/Pasted%20image%2020240306205217.png)

![](../!assets/attachments/Pasted%20image%2020240306205040.png)


![](../!assets/attachments/Pasted%20image%2020240306205045.png)
- https://leetcode.com/problems/sliding-window-maximum/solutions/66023/on-solution-cutting-the-array-into-segments-explanation-and-c-implementation/







![](../!assets/attachments/Pasted%20image%2020240306205122.png)

---












```
public int[] maxSlidingWindow(int[] nums, int k) {
  // assume nums is not null
  if (nums.length == 0 || k == 0) {
    return new int[0];
  }
  int n = nums.length;
  int[] result = new int[n - k + 1]; // number of windows
  
  // left & right
  int[] left = new int[n];
  int[] right = new int[n];
  left[0] = nums[0]; // init
  right[n - 1] = nums[n - 1];
  
  for (int i = 1; i < n; ++i) {
    // left
    if (i % k == 0) left[i] = nums[i];
    else            left[i] = Math.max(left[i - 1], nums[i]);
    // right
    int j = n - i - 1;
    if (j % k == (k - 1)) right[j] = nums[j];
    else                  right[j] = Math.max(right[j + 1], nums[j]);
  }
  
  // dp
  for (int i = 0, j = i + k - 1; j < n; ++i, ++j) {
    result[i] = Math.max(right[i], left[j]);
  }
  
  return result;
}

```

- complexity
	- O(n) time
	- O(n) space

![](../!assets/attachments/Pasted%20image%2020240306122900.png)
![](../!assets/attachments/Pasted%20image%2020240306122951.png)




