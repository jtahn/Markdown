[424. Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/)

You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.

Return _the length of the longest substring containing the same letter you can get after performing the above operations_.

**Example 1:**  
**Input:** `s = "ABAB", k = 2`  
**Output:** `4`  
**Explanation:** Replace the two 'A's with two 'B's or vice versa.  

**Example 2:**  
**Input:** `s = "AABABBA", k = 1`  
**Output:** `4`  
**Explanation:** Replace the one 'A' in the middle with 'B' and form "AABBBBA".  
The substring "BBBB" has the longest repeating letters, which is 4.  
There may exists other ways to achieve this answer too.  

**Constraints:**
- `1 <= s.length <= 10^5`
- `s` consists of only uppercase English letters.
- `0 <= k <= s.length`

---


# Brute force
- strategy

 
	- so let say this solution has length `m`
	- this means any solution has length `m`
	- we need to show that there is at least one substring of length `m` where the brute force routine provides a solution
		- observe:
			- brute force routine: a length m substring will provide a solution if the most frequent letter has count m-k
		- observe
			- recall key idea: a length m substring is a solution if there exists a letter with m-k occurrences
		- conclusion
			- yes, the routine will get things done
		- suppose there are no substrings where most frequent letter has count m-k
			- then there is no possible way to replace stuff to get m repeating chars
			- but then this implies there is no solution of length m 
			- actually: above 2 points are just repeating the observation...
	- based on 'key idea' above, it suffices to check that a solution will be found when the simple routine is ran on substrings of length `m`
		- ie there is at least one substring `t` of length `m`, that will generate a solution when you do this process
			- we can show better: 
			- (meta: this proof for brute force is key to understanding the later sliding window; ie we see now, another key piece of info is num counts of most frequent letters; if it's m-k, then we're guaranteed a solution; if it's less, then there's no solution)
				- ie this is literally equivalent condition to finding a solution
				- and so this is partly why you now keep track of this in the sliding window...
		- suppose `t` is a substring of length m that could generate a solution
			- actually i think the key is just
				- recall observation: this substring generates a solution IFF there exists a letter with exactly $m-k$ occurrences
				- and you know that there has to be at least one substring that does this...otherwise m wouldnt be your answer, it'd have to be less
			- (explanation attempt) i.e. for some `A`, if we replace all non-`A` chars, then we have a solution
				- (remember this means the number of `A` chars in `t` is $m-k$)
				- (another seemingly worse alternative explanation)
					- case 1:
						- A is the unique most frequent letter
							- then we get a solution
					- case 2:
						- A is tied for most frequent
							- then it doesn't matter 
					- case 3:
						- A is not most frequent
							- cannot happen: this means solution should have length at least m+1
					- (todo: possible alternative explanation...seems worse though...)
					- case 1: if m-k > k
						- then `A` is guaranteed to be the most frequent letter, and so we will get a solution
					- case 2: if m-k <= k:
						- `A` is not guaranteed to be most frequent
						- can another letter `B` be more frequent? 
							- 
						- we have to confirm that either:
							- `A` is still the kept letter
							- if it is not the kept letter, we still have a solution
						- then a different letter `B` might be replaced
						- note:
							- the number of B chars in `t` must also be $m-k$
								- if it was less: then B wouldn't have been picked as the kept character
								- if it was more: then solution has length at least m+1
- complexity (let n be length of the string)
	- O(n^3) time
		- O(n^2) to loop over every substring
			- O(m) to compute letter counts (we know hashing is optimal)
			- O(m) to replace
		- so O(n^2 m)
		- (i think) asymptotically m=n
	- O(n) space
		- O(m) for hashmap to store letter counts
		- O(m) to build the modified substring
		- we can toss/empty/re-use this workspace when we move onto the next substring
		- again, asymptotically m=n



# Sliding window
```
class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        count = {}
        
        l = 0
        maxf = 0
        for r in range(len(s)):
            count[s[r]] = 1 + count.get(s[r], 0)
            maxf = max(maxf, count[s[r]])

            if (r - l + 1) - maxf > k:
                count[s[l]] -= 1
                l += 1

        return (r - l + 1)
```

- high level summary
	- for each char, check if it could create the longest repeating substr, use sliding window to optimize; check if windowlen=1 works, if yes, increment len, if not, shift window right;
- observation 1: equivalent definition of solution
	- fix an instance of this problem
	- let `m` be the length of a solution to this instance
		- (meta: this step is key to understanding what solutions look like)
		- note solutions are not necessarily unique
		- however, we do know they all have the same length
	- then a solution is any substring `t` of length $m$ such that:
		- there exists a letter with (exactly) $m-k$ occurrences in `t`
			- can't be higher, else we could just add increase substring on either side, do replacements, and have a substring with m+1 repeats
			- can't be lower else this wouldn't have been a solution; bc no way to get to m repeats
			- it's fine if there's multiple letters satisfy this; regardless of which letter you keep, then you get a string with m repeats
		- (because then, we can change the other $k$ letters to match that letter)
		- ie equivalent formulation of the problem:
			- find longest substring where (length - count of most frequent character) <= k
- proof: why we can ignore states
	- summary
		- right pointer
			- we dont care about substrings with length below currMaxLength
		- left pointer
			- we dont care about substrings starting here, bc we know there are no solutions with length above currMaxlength
			- (note: when left pointer is moved, we move auto move right pointer as well without even needing to check the state before we move it..bc we alrdy know we can throw it away, bc substring isnt long enouhg to care)
	- why we can move left pointer
		- this happens when we're alrdy at the max cap of 'replaced' letters
		- we know that substring of length m starting at this left pointer is not a solution
			- this implies: cannot be a solution of any length higher than m as well
			- any length lower than m we dont care about, bc we've alrdy found a solution
		- thus, no need to check substrings starting at this pointer anymore
		- (meta: ohh...ok so i tihnk 'moving the pointer' is the only time we need to discuss why states dont matter; ie this is what we did in other two pointer solutions where they were both moving inward)
			- aka: i dont think 'why we can ignore lower max count' actually has much to do with 'states'...i mean i guess it does...wait yea:
			- moving right pointer is the fact that:
				- if we have alrdy found length m, then we dont need to check for that length anymore; we check for m+1
		- (i'm trying to say that for any kind of two pointer method, for correctness, any time you move a pointer, it implies you're throwing away states, so i need to explain why this is allowed; ie moving right pointer here means you're throwing away certain substring lengths; and moving left pointer means you're throwing away certain 'starting' points)
- complexity
	- O(n) time
	- O(1) space


![](../!assets/attachments/Pasted%20image%2020240305182903.png)

![](../!assets/attachments/Pasted%20image%2020240305124914.png)




![](../!assets/attachments/Pasted%20image%2020240305182830.png)


