[424. Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/)

You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.

Return _the length of the longest substring containing the same letter you can get after performing the above operations_.

**Example 1:**  
**Input:** `s = "ABAB", k = 2`  
**Output:** `4`  
**Explanation:** Replace the two 'A's with two 'B's or vice versa.  

**Example 2:**  
**Input:** `s = "AABABBA", k = 1`  
**Output:** `4`  
**Explanation:** Replace the one 'A' in the middle with 'B' and form "AABBBBA".  
The substring "BBBB" has the longest repeating letters, which is 4.  
There may exists other ways to achieve this answer too.  

**Constraints:**
- `1 <= s.length <= 10^5`
- `s` consists of only uppercase English letters.
- `0 <= k <= s.length`

---


# Equivalent definition of solution
- possible names/descriptions for this observation:
	- equivalent definition of solution
	- to determine a solution: we only care about the count of the most frequent character
- fix an instance of this problem
- let `m` be the length of a solution to this instance
	- (meta/todo: fixing a length is key to understanding what solutions look like)
		- wait maybe not? equivalent formulation of problem:
			- find longest substring where (length - count of most frequent character) <= k
	- note solutions are not necessarily unique
	- however, we do know they all have the same length
- then a solution is any substring `t` of length $m$ such that:
	- there exists a letter with (exactly) $m-k$ occurrences in `t`
		- can't be higher, else we could just add increase substring on either side, do replacements, and have a substring with m+1 repeats
		- can't be lower else this wouldn't have been a solution; bc no way to get to m repeats
		- it's fine if there's multiple letters satisfy this; regardless of which letter you keep, then you get a string with m repeats
	- (because then, we can change the other $k$ letters to match that letter)

# Brute force
- this is 'brute force' informed by the equivalent definition above
	- you can come up with far more brutal 'brute forces' if you don't use the above property
- strategy
	- iterate over all substrings
		- let m be length of current substring
		- using property above, it is sufficient to check if there is a character present at least m-k times
	- return highest m where the check succeeded
- why i mention this brute force:
	- the property above already leads to an algo that is pretty simple to understand
	- the diff btwn this algo and sliding window:
		- sliding window essentially figures out how we can iterate over substrings efficiently

# Sliding window
```
class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        count = {}
        
        l = 0
        maxf = 0
        for r in range(len(s)):
            count[s[r]] = 1 + count.get(s[r], 0)
            maxf = max(maxf, count[s[r]])

            if (r - l + 1) - maxf > k:
                count[s[l]] -= 1
                l += 1

        return (r - l + 1)
```

- high level summary
	- for each char, check if it could create the longest repeating substr, use sliding window to optimize; check if windowlen=1 works, if yes, increment len, if not, shift window right;
- observation: the 'simple routine' inside brute force is good, but we can drastically improve how we iterate
	- ie we can ignore a lot of substring/states
- proof: why we can ignore states
	- summary
		- right pointer
			- we dont care about substrings with length below currMaxLength
		- left pointer
			- we dont care about substrings starting here, bc we know there are no solutions with length above currMaxlength
			- (note: when left pointer is moved, we move auto move right pointer as well without even needing to check the state before we move it..bc we alrdy know we can throw it away, bc substring isnt long enouhg to care)
	- why we can move left pointer
		- this happens when we're alrdy at the max cap of 'replaced' letters
		- we know that substring of length m starting at this left pointer is not a solution
			- this implies: cannot be a solution of any length higher than m as well
			- any length lower than m we dont care about, bc we've alrdy found a solution
		- thus, no need to check substrings starting at this pointer anymore
		- (meta: ohh...ok so i tihnk 'moving the pointer' is the only time we need to discuss why states dont matter; ie this is what we did in other two pointer solutions where they were both moving inward)
			- aka: i dont think 'why we can ignore lower max count' actually has much to do with 'states'...i mean i guess it does...wait yea:
			- moving right pointer is the fact that:
				- if we have alrdy found length m, then we dont need to check for that length anymore; we check for m+1
		- (i'm trying to say that for any kind of two pointer method, for correctness, any time you move a pointer, it implies you're throwing away states, so i need to explain why this is allowed; ie moving right pointer here means you're throwing away certain substring lengths; and moving left pointer means you're throwing away certain 'starting' points)
		- (i feel like these metas arent helpful...the whole point of my leetcode deck was that i would inductively/indirectly get a feel for the situations where things work, without getting to vague/broad/theory (which honestly makes understanding it harder); having a writeup describing this is too vague and honestly unhelpful; if it want to get a sense of how these techniques are related, then i just look in my ToC and read all the problems that use a similar technique)
			- specifically: i DO need to discuss why i can move pointers, bc that is how i prove correctness
			- i DONT have to mention like: "all two pointer solutions do this stuff all the time"...i should inductively realize this bc all my two pointer methods do this...
- complexity
	- O(n) time
	- O(1) space


![](../!assets/attachments/Pasted%20image%2020240305182903.png)

![](../!assets/attachments/Pasted%20image%2020240305124914.png)



![](../!assets/attachments/Pasted%20image%2020240305182830.png)


