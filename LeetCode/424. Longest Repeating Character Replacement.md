[424. Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/)

You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.

Return _the length of the longest substring containing the same letter you can get after performing the above operations_.

**Example 1:**  
**Input:** `s = "ABAB", k = 2`  
**Output:** `4`  
**Explanation:** Replace the two 'A's with two 'B's or vice versa.  

**Example 2:**  
**Input:** `s = "AABABBA", k = 1`  
**Output:** `4`  
**Explanation:** Replace the one 'A' in the middle with 'B' and form "AABBBBA".  
The substring "BBBB" has the longest repeating letters, which is 4.  
There may exists other ways to achieve this answer too.  

**Constraints:**
- `1 <= s.length <= 10^5`
- `s` consists of only uppercase English letters.
- `0 <= k <= s.length`

---

# key ideas
- what does a solution to this problem look like?
	- fix an instance of this problem
	- let `m` be the length of a solution to this instance
		- note solutions are not necessarily unique
		- however, we do know they all have the same length
	- then a solution is any substring `t` of length $m$ such that:
		- there exists a letter with (exactly) $m-k$ occurrences in `t`
			- can't be higher, else we could just add increase substring on either side, do replacements, and have a substring with m+1 repeats
			- can't be lower else this wouldn't have been a solution; bc no way to get to m repeats
			- it's fine if there's multiple letters satisfy this; regardless of which letter you keep, then you get a string with m repeats
		- (because then, we can change the other $k$ letters to match that letter)
- so this problem has a lot of added fluff to make it seem more complicated than it actually is
	- all we are doing is finding the largest $m$ where:
		- there exists a substring of length $m$ with $m-k$ letters are the same
- note we actually don't have to replace anything:
	- the question just asks for the length; doesnt ask for the string
	- so whatever algo we do, doesnt need to do a replacement...



![](../!assets/attachments/Pasted%20image%2020240305124953.png)

# Brute force
- strategy
	- for every substring `t` of `s`
		- decide how to replace
			- compute letter counts
			- identify a most frequent letter
				- (wlog, suppose it's the letter `A`)
		- perform replacements
			- change the first `k` non-`A` chars into `A` chars
		- compute length of the "repeating `A`" substring of `t`
- proof
	- we know a solution exists
		- because you could do 'most brutish brute force of all time' where you check every substring and try every possible replacement
			- better: every substring, and every possible replacement: this gets associated with a value (longest repeating substring)
			- this is clearly all possibilities
			- there is a max value here of n
			- solution is just anything that achieves the max of this set (max exists) bc bounded discrete set
			- (i dont think finite number of possibilities) has anything to do with it;
				- it's more just: finite (more specifically: discrete and bounded) number of possible outputs 
			- [Brute force methods](../Blurbs/Brute%20force%20methods.md)
				- issue: i think this method i just described above, is the 'true' brute force method
				- so there needs to be some kind of distinguishing btwn how 'brutal' a brute force method is...
				- like there's various efficiencies to make on the brutal force method described above:
					- we dont actually have to replace chars; bc we know equivalent characterization of solution from the key idea above
						- also problem doesnt ask for an actual string; just asks for max length...so this should hint that actually going through the process of replacing characters, is a waste
					- we dont have to loop through every possible substring
						- this is what leads to two pointer
					- counter chars can be done efficiently via hashing
		- better argument: 
			- we already know a lower bound is strings of length 1+k
			- upper bound is length n
			- this isn't really arguing anything though...
			- (what i'm trying to say is: lower and upper bound)
		- these arguments seem way too high powered lol...
	- so let say this solution has length `m`
	- this means any solution has length `m`
	- we need to show that there is at least one substring of length `m` where the brute force routine provides a solution
		- observe:
			- brute force routine: a length m substring will provide a solution if the most frequent letter has count m-k
		- observe
			- recall key idea: a length m substring is a solution if there exists a letter with m-k occurrences
		- conclusion
			- yes, the routine will get things done
		- suppose there are no substrings where most frequent letter has count m-k
			- then there is no possible way to replace stuff to get m repeating chars
			- but then this implies there is no solution of length m 
			- actually: above 2 points are just repeating the observation...
	- based on 'key idea' above, it suffices to check that a solution will be found when the simple routine is ran on substrings of length `m`
		- ie there is at least one substring `t` of length `m`, that will generate a solution when you do this process
			- we can show better: 
			- (meta: this proof for brute force is key to understanding the later sliding window; ie we see now, another key piece of info is num counts of most frequent letters; if it's m-k, then we're guaranteed a solution; if it's less, then there's no solution)
				- ie this is literally equivalent condition to finding a solution
				- and so this is partly why you now keep track of this in the sliding window...
				- meta: maybe this is another example/observation to add to [Brute force methods](../Blurbs/Brute%20force%20methods.md)
					- basically: brute force method: the routine does not always generate a solution
					- but: the cases where it DOES generate a solution: usually there's some key piece of info that exactly determines/equivalent to whether the routine generates a solution or not; and this key piece of info is part of what contributes to an efficient optimization
		- suppose `t` is a substring of length m that could generate a solution
			- actually i think the key is just
				- recall observation: this substring generates a solution IFF there exists a letter with exactly $m-k$ occurrences
				- and you know that there has to be at least one substring that does this...otherwise m wouldnt be your answer, it'd have to be less
			- (explanation attempt) i.e. for some `A`, if we replace all non-`A` chars, then we have a solution
				- (remember this means the number of `A` chars in `t` is $m-k$)
				- (another seemingly worse alternative explanation)
					- case 1:
						- A is the unique most frequent letter
							- then we get a solution
					- case 2:
						- A is tied for most frequent
							- then it doesn't matter 
					- case 3:
						- A is not most frequent
							- cannot happen: this means solution should have length at least m+1
					- (todo: possible alternative explanation...seems worse though...)
					- case 1: if m-k > k
						- then `A` is guaranteed to be the most frequent letter, and so we will get a solution
					- case 2: if m-k <= k:
						- `A` is not guaranteed to be most frequent
						- can another letter `B` be more frequent? 
							- 
						- we have to confirm that either:
							- `A` is still the kept letter
							- if it is not the kept letter, we still have a solution
						- then a different letter `B` might be replaced
						- note:
							- the number of B chars in `t` must also be $m-k$
								- if it was less: then B wouldn't have been picked as the kept character
								- if it was more: then solution has length at least m+1
- complexity (let n be length of the string)
	- O(n^3) time
		- O(n^2) to loop over every substring
			- O(m) to compute letter counts (we know hashing is optimal)
			- O(m) to replace
		- so O(n^2 m)
		- (i think) asymptotically m=n
	- O(n) space
		- O(m) for hashmap to store letter counts
		- O(m) to build the modified substring
		- we can toss/empty/re-use this workspace when we move onto the next substring
		- again, asymptotically m=n



# Sliding window
- proof: why we can ignore states
	- summary
		- right pointer
			- we dont care about substrings with length below currMaxLength
		- left pointer
			- we dont care about substrings starting here, bc we know there are no solutions with length above currMaxlength
			- (note: when left pointer is moved, we move auto move right pointer as well without even needing to check the state before we move it..bc we alrdy know we can throw it away, bc substring isnt long enouhg to care)
	- why we can move left pointer
		- this happens when we're alrdy at the max cap of 'replaced' letters
		- we know that substring of length m starting at this left pointer is not a solution
			- this implies: cannot be a solution of any length higher than m as well
			- any length lower than m we dont care about, bc we've alrdy found a solution
		- thus, no need to check substrings starting at this pointer anymore
		- (meta: ohh...ok so i tihnk 'moving the pointer' is the only time we need to discuss why states dont matter; ie this is what we did in other two pointer solutions where they were both moving inward)
			- aka: i dont think 'why we can ignore lower max count' actually has much to do with 'states'...i mean i guess it does...wait yea:
			- moving right pointer is the fact that:
				- if we have alrdy found length m, then we dont need to check for that length anymore; we check for m+1
		- (i'm trying to say that for any kind of two pointer method, for correctness, any time you move a pointer, it implies you're throwing away states, so i need to explain why this is allowed; ie moving right pointer here means you're throwing away certain substring lengths; and moving left pointer means you're throwing away certain 'starting' points)
	- meta: this is making me think: two pointer is just:
		- 'efficiently iterated brute force'
		- aka: the 'actual routine' is identical to brute force; but we handle the iteration in a way that adaptively throws away any future cases/subsets that you alrdy no there's no point checking (ie bc the result will be 'useless' in terms of updating your 'current best solution')
		- maybe this is an example of why [Brute force methods](../Blurbs/Brute%20force%20methods.md)




- complexity
	- O(n) time
	- O(1) space

![](../!assets/attachments/Pasted%20image%2020240305124914.png)




![](../!assets/attachments/Pasted%20image%2020240305134837.png)

