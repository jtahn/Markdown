[739. Daily Temperatures](https://leetcode.com/problems/daily-temperatures/)

```
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        
```

Given an array of integers `temperatures` represents the daily temperatures, return _an array_ `answer` _such that_ `answer[i]` _is the number of days you have to wait after the_ `ith` _day to get a warmer temperature_. If there is no future day for which this is possible, keep `answer[i] == 0` instead.

**Example 1:**  
**Input:** `temperatures = [73,74,75,71,69,72,76,73]`  
**Output:** `[1,1,4,2,1,1,0,0]`  

**Example 2:**  
**Input:** `temperatures = [30,40,50,60]`  
**Output:** `[1,1,1,0]`  

**Example 3:**  
**Input:** `temperatures = [30,60,90]`  
**Output:** `[1,1,0]`  

**Constraints:**
- `1 <= temperatures.length <= 10^5`
- `30 <= temperatures[i] <= 100`

---
# Brute force
- strategy
	- for each day
		- iterate through rest of the days until we hit warmer
- complexity
	- O(n^2)


# Monotonic stack

```
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        res = [0] * len(temperatures)
        stack = []  # pair: [temp, index]

        for i, t in enumerate(temperatures):
            while stack and t > stack[-1][0]:
                stackT, stackInd = stack.pop()
                res[stackInd] = i - stackInd
            stack.append((t, i))
        return res
```

![](../!assets/attachments/Pasted%20image%2020240307223749.png)

- summary
	- push the index of the current temperature to the stack if it cannot find a higher temperature immediately. Subsequently, with each new day's temperature, we compare it against the peak temperatures on the stack until we find one that is lower or until the stack is empty
	-  a monotonic stack in which, instead of storing the values, we store indices and ensure that the temperatures related to these indices are in ascending order. A monotonic stack is helpful when dealing with problems where we need to know the next greater or smaller element in an array.
	- Store currently unsolved elements, later if there is a bigger number, withdraw the unsolved elements and get the answer.
- observation
	- The intuition behind the solution is to use a stack that helps to track the temperatures and indexes. We traverse the temperatures from left to right, and for each day's temperature, we check whether it is higher than the temperature at the indexes recorded on the stack. If so, this means we have found a day with a warmer temperature for the days corresponding to those indexes. Therefore, for each such index, j, we can update answer[j] to the current day's index minus j, indicating the number of days that had to be waited.
	- The stack keeps track of indexes with temperatures that we haven't yet found a warmer day for. This is an effective approach because the temperatures are processed in order and the stack ensures we only compare temperatures where the future warmer temperature hasn't been found yet. When a warmer temperature is encountered, it is the immediate next warmer temperature for all temperatures currently in the stack. Once updated, we no longer need to consider those days because their next warmer temperature has been determined.
	- In cases where there are no warmer temperatures in the future, the answer will remain 0 by default, as established at the start of the solution.
- strategy
	- monotonic decreasing stack
		- so if any incoming value is larger, we must pop values off the top of the stack, until it satisfies rules 1 or 2 before we can add it to our stack.
	- Create an empty stack `stk` that will store indices of the temperatures array.
	- While there are indices on the stack and the current temperature `t` is greater than the temperature at the top index of the stack (i.e., `temperatures[stk[-1]] < t`), pop the index `j` from the top of the stack. This indicates that we have found a warmer day for the day at index `j`.
	- Calculate the number of days waited for index `j` by subtracting `j` from the current index `i` (i.e., `ans[j] = i - j`). This gives us the number of days that had to pass to reach a warmer temperature.
	- Continue popping from the stack and updating the `ans` array until the stack is empty or a day with a lower temperature is found.
	- If the current day's temperature isn't higher than the temperature at the top index of the stack, or if the stack is empty, push the current index `i` onto the stack. This signifies that we are still looking for a future warmer temperature for this day.
	- Once we exit the loop, we have filled out the `ans` array with the number of days to wait for a warmer temperature after each day. In cases where we do not find a warmer temperature, the default value of `0` remains.
- complexity
	- O(n) time amortized
		- each element is processed as it's pushed into the stack stk and then processed again when it's popped from the stack. Each element can be pushed and popped at most once 
	- O(n) space
		- auxiliary stack `stk` that, in the worst case, might contain all temperature indices (N) at some point in time
		- Additionally, we have an array ans to store the answer for each day, which also contains N elements.
- note
	- your stack can store just the index; bc you can always look up the temp
		- or can store (temp, index)
		- either work

## can iterate backwards?


- equivalent: can iterate backwards; you just flip all the inequalities
	- ....this is really unintuitive imo...idk if it's worth having this...
	- why does it feel unintuitive? imo figure this out
	- imo it feeling this unintuitive means that its exactly not the right intuition here
- 
![](../!assets/attachments/Pasted%20image%2020240307224319.png)



# Hashing/indexing
- inspiration
	- ![](../!assets/attachments/Pasted%20image%2020240307225731.png)
		- i think you can modify this guys method to do it in place
			- so it would be O(1) space complexity
- strategy
	- iterate backwards
	- replaces indices in the `temp` array as you encounter them
		- so if you replace, you're replacing with a smaller (aka more recent) index, for days you will iterate over later (which are actually, days in the past)
	- my claim is: once you hash/store a temp's index...why do you need it in the original array anymore?
		- so why not just overwrite the original array
- complexity
	- time
		- would technically still be O(n), but the constant in the worst case is certainly much larger than the monotonic stack method
		- ie rn we have 70 possible temps, so this is like O(70n)
		- versus i think monotonic stacks, its more like O(2n)
	- 