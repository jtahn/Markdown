[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/)

```
class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        
```

Koko loves to eat bananas. There are `n` piles of bananas, the `ith` pile has `piles[i]` bananas. The guards have gone and will come back in `h` hours.

Koko can decide her bananas-per-hour eating speed of `k`. Each hour, she chooses some pile of bananas and eats `k` bananas from that pile. If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.

Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return.

Return _the minimum integer_ `k` _such that she can eat all the bananas within_ `h` _hours_.

**Example 1:**  
**Input:** `piles = [3,6,7,11], h = 8`  
**Output:** `4`  

**Example 2:**  
**Input:** `piles = [30,11,23,4,20], h = 5`  
**Output:** `30`  

**Example 3:**  
**Input:** `piles = [30,11,23,4,20], h = 6`  
**Output:** `23`  

**Constraints:**
- `1 <= piles.length <= 10^4`
- `piles.length <= h <= 10^9`
- `1 <= piles[i] <= 10^9`

---



# Binary search


- complexity
	- time
		- Time Complexity: O(N log W), where N is the number of piles, and W is the maximum size of a pile, space is O(1).
		- O(NlogM) where M is the max number of bananas in a pile (i.e., max speed) because the Binary Search is on the range of eating speed and not on the range of piles.
- strategy
	- do binary search on the range of possible rates
		- 1 being slowest and the biggest pile being the fastest rate of banana consumption
			- no point setting fastest rate higher, bc koko stops eating that hr if she finishes a pile
		- range adjustment depends on whether koko finished the nanas or not
- python note
![](../!assets/attachments/Pasted%20image%2020240310165603.png)


---

IMPORTANT:

- question: can you use 3 cases here?
	- i feel the answer is no...
	- bc even if the rate results in hitting the hour threshold; you wouldn't want to break, because it's possible a slower rate still meets the hour threshold as well
	- so you need to use the 2 cases approach here
	- aka you're trying to find the lowest possible rate that meets the hour threshold


![](../!assets/attachments/Pasted%20image%2020240310171246.png)
![](../!assets/attachments/Pasted%20image%2020240310171230.png)

---


- You may use `ceil(sum(piles)/H)` as the lower bound instead of `1` to narrow down the searching range.
	- note: the initial lower bound should NOT be min piles:
		- ie the result can be smaller than the min(piles)
		- e.g.: arr = {2, 6}, h = 8



`(p + m - 1) / m` equal to `ceil(p / m)` (just personal behavior)


- PYTHON BEWARE (probly python 2 vs python3)
	- I am not sure if the input has changed since this was written, but if you're trying to use math.ceil(p/m) you're going to get integer division first, so make sure to convert one of them to float first. I spent a bunch of time trying to figure out why math.ceil was not working.
	- Changing to `float` won't work. This works: `Math.ceil(p*1.0/m)`



```
class Solution(object):
    def minEatingSpeed(self, piles, h):
        low, high = 1, 10 ** 9
        while low <= high:
            k = (low + high) // 2
            if sum(math.ceil(1.0 * pile / k) for pile in piles) > h: low = k + 1
            else: high = k - 1
        return low
    
    
    
    def minEatingSpeed(self, piles, H):
        l, r = 1, max(piles)
        while l < r:
            m = (l + r) / 2
            if sum((p + m - 1) / m for p in piles) > H:
                l = m + 1
            else:
                r = m
        return l



class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        l, r = 1, max(piles)
        res = r

        while l <= r:
            k = (l + r) // 2

            totalTime = 0
            for p in piles:
                totalTime += math.ceil(float(p) / k)
            if totalTime <= h:
                res = k
                r = k - 1
            else:
                l = k + 1
        return res

```

