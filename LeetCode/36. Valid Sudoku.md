[36. Valid Sudoku](https://leetcode.com/problems/valid-sudoku/)

Determine if a `9 x 9` Sudoku board is valid. Only the filled cells need to be validated **according to the following rules**:

1. Each row must contain the digits `1-9` without repetition.
2. Each column must contain the digits `1-9` without repetition.
3. Each of the nine `3 x 3` sub-boxes of the grid must contain the digits `1-9` without repetition.

**Note:**
- A Sudoku board (partially filled) could be valid but is not necessarily solvable.
- Only the filled cells need to be validated according to the mentioned rules.

**Example 1:**  
![](../!assets/attachments/Pasted%20image%2020240224212641.png)  
**Input:**  
```
board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
```  
**Output:** `true`    

**Example 2:**  
**Input:**  
```
board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
```  
**Output:** `false`  
**Explanation:** Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.  

**Constraints:**
- `board.length == 9`
- `board[i].length == 9`
- `board[i][j]` is a digit `1-9` or `'.'`.

---

# todo

- brute force complexity is O(n^3) time
	- for each cell (count n^2)
		- we check for collisions in its row, column, and sub-box (3n entries to check)

- 2sum should be fundamental example of:
	- key idea 1: existence ‘back-checking’: check for existence only on stuff you’ve already iterated over
		- versus naive/brute methods: check for existence on everything
- then sudoku cites this technique; sudoku is honestly an identical problem tbh...

- maybe sudoku is fundamental prob for:
	- key idea 2: ‘lazy storage’ 
		- you can use just 1 set: just hash stuff in a ‘different’ way when necessary
- tuple or string are both standard here
- maybe this problem: explain python hashing in more detail, for tuples and strings


- consider: deleting the other ‘storage ideas’
	- imo: these are not the ‘best intuition’ for how to solve this problem
	- otoh: the trick for how they manage indexing for sub-boxes..seem interesting enough to keep
	- also, keeping track of converting between ints and string, and needing to start at 0 or 1

- the ‘3 separate structures’ technique:
	- it’s still the same key idea of: only check for collisions among things we’ve already iterated over
	- it’s just, how it’s implemented is different..question is, is this implementation valuable?


- keep bitmasking optimization
	- this will not be fundamental problem for bitmasking; there are future problems on bits in the neetcode list
	- todo: cite a bitmasking technique in the future, and then delete most of the explanation here
	- that problem will explain it + python implementation, etc

- jargon
	- “collisions”


- 2sum should also contain:
	- python tricks
		- checking for membership testing and adding to set at the same time.
- in general, when editing this problem: a lot of edits/adjustments can actually just be moved to 2-sum problem, bc it really is fundamentally identical

- 2sum is: “fundamental problem of using sets to check collisions with records we’ve already visited”

- sudoku gives more practice on how you implement collision check
	- ie need to store things in a way that is useful for future records you visit
	- any ‘choice’ of how to store: there’s often many related ways that are essentially the same idea, and modifying the ‘stored key’ corresp to performing the same/invert modification to the ‘collision check routine’
		- (so more complicated problem: do not need to explain how/why there are many variants on what you could store/check)
	- ie 2sum actually has 2 options, but they’re essentially just inverses of each other:
		- store num; check for target-num
		- or store target-num: check for num
	- sudoku: could use tuple or string



- the solutions near the end are a different/extra key idea:
	- call it “1d space”
		- maybe call the other stuff: “3d space”
	- still use key idea 1 above 
	- the new key idea for O(n) space: iterate ‘dimensions’ separately
		- i.e. instead of doing all of row, column, and sub-block at the same time, you just do them each once.
- probly sacrifice some time complexity constant, bc loop through all elements thrice
	- but asymptotically should be the same



- the ‘claimed log n space’ is surely this approach as well; the complexity likely is just because of the bit masking/memoization
	- ie without bitmasking: it would be O(n) space...still better than the previous examples
	

- bitmasking shouldnt be a main heading, imo this is not a fundamental idea of this problem



- what complexity do i pick for [36. Valid Sudoku](../LeetCode/36.%20Valid%20Sudoku.md)
	- see [complexity analysis wrt "spirit of the problem"](../Blurbs/complexity%20analysis%20wrt%20"spirit%20of%20the%20problem".md)
	- spirit of the problem results in trivial space complexity
	- the ‘arbitrary size sudoku’ variant makes the complexity analysis a lot more interesting...
	- (todo: figure out how i should do complexity analysis for sudoku)

- the spirit of the problem seems to be:
	- 1-9 really should be considered finite range
	- so, much of the space complexity should probably be O(1)
	- todo: for now, consider the grid size / valid number ‘range’ to be an arbitrary N
		- ie a sudoku where side lengths are N^2
		- so ‘true sudoku’ is where N=3
			- ie the ‘generating number’ is actually 3, not 9
- one way to see this: dims of sub-blocks are NxN 
	- if i find a new problem that is essentially the ‘arbitrary N’ version of the problem: then change sudoku to be O(1)
	- also see the relevant blurb/brownie points






# Brute force
- strategy
	- for each cell that has a digit
		- check if digit is repeated in the same row, column, and sub-box
- complexity (n is the side length) (note n is also size of sub-box)
	- O(n^3) time
		- for each cell (up to count n^2), we check row/column/box (count 3n)
	- O(1) space

# "Efficient lookups"
```
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        cols = collections.defaultdict(set)
        rows = collections.defaultdict(set)
        squares = collections.defaultdict(set)  # key = (r /3, c /3)

        for r in range(9):
            for c in range(9):
                if board[r][c] == ".":
                    continue
                if (
                    board[r][c] in rows[r]
                    or board[r][c] in cols[c]
                    or board[r][c] in squares[(r // 3, c // 3)]
                ):
                    return False
                cols[c].add(board[r][c])
                rows[r].add(board[r][c])
                squares[(r // 3, c // 3)].add(board[r][c])

        return True
```

- above is via dict of sets; below is list of lists
```
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        rows = [[False] * 9 for _ in range(9)]
        cols = [[False] * 9 for _ in range(9)]
        boxes = [[False] * 9 for _ in range(9)]

        # Iterate over each cell in the 9x9 board.
        for i in range(9):
            for j in range(9):
                cell_value = board[i][j]
                # Skip checking if the cell is empty.
                if cell_value == '.':
                    continue
              
                # Convert str digit to int and adjust index to zero-based.
                num = int(cell_value) - 1
              
                # Calculate box index for 3x3 sub-boxes using integer division.
                box_index = (i // 3) * 3 + j // 3
              
                # If the number has already been encountered in current
                # row, column or box, sudoku condition is violated.
                if rows[i][num] or cols[j][num] or boxes[box_index][num]:
                    return False
              
                # Mark current num as encountered in current row, column and box.
                rows[i][num] = True
                cols[j][num] = True
                boxes[box_index][num] = True

        # If no conditions are violated, then the board is a valid sudoku.
        return True
```





- intuition
	- sacrifice space for time
	- it is sufficient to check for repeats among nodes that we have already iterated over
		- ie: still check if digit is repeated in the same row/column/sub-box, but only among nodes we've already iterated over
	- as we iterate, use memoization/structures so that these checks can be done in O(1) time instead of O(n)
		- ie dont naively check by iterating through 3n entries (the row, column, box)
		- idea
			- suppose node `(i,j)` contains `num`
			- then we want a structure `row` so that `row[i]` tells us if `num` has already been found in the `i^th` row
			- and similarly have data structures `col` and `sub`
		- intuition, aka why we should think of this?
			- we only care about existence/encountered, which is simple to store
			- it simple to hash/index the vars `i,j,num`
- what data structure?
	- hashing
		- dict of sets
		- list of sets
	- list of lists
		- if this problem generalized to much larger size, then maybe don't use this if your puzzles are generally sparse
- for each nonempty cell
	- check for collisions
		- hashing: check if `num` in
			- `row[i]`
			- `col[j]`
			- for sub-boxes:
				- for dict of sets, `sub[(i//3, j//3)]`
				- for list of sets, `sub[i//3 * 3 + j//3]`
					- note: we need to assign an index to the sub-boxes
					- the typical choice here is `i//3 * 3  + j//3`
					- versus for dict of sets, can just use `(i//3, j//3)` as a key
		- 2d list: check if any are storing `true`
			- `row[i][num]`
			- `col[j][num]`
			- `sub[i//3 * 3  + j//3][num]`
			- NOTE: valid numbers are 1-9; and in the board are strings; this means that the corresponding index for the inner list is actually `int(num)-1`
				- ie more precise to write: `row[i][int(num)-1]`
	- if no collisions, then mark it in the structure. ie:
		- set: add it to the set
		- 2d list: change the bool to `true`
- complexity
	- O(n^2) time
		- iterate over entire board; checks/updates are O(1)
	- O(n^2) space
		- each structure `row,col,sub` is size O(n^2)
		- some ppl will say O(1) bc sudoku is fixed 9x9..idk this isn't reasonable imo, bc same argument says that time complexity is O(1)




## optimization: bitmasking 
- reduce space complexity bc we only care about existence
- so instead of a structure `row`, we use a "bitmask" `row` where bit `row[i]` is 0 or 1
- complexity
	- O(n^2) time
	- space
		- i don't think it's O(n), but i don't think it's O(n^2) either
		- actually might essentially be O(n)
			- we have 3 structures that each contain n 'bitmasks'
			- my issue is that: the 'size' of the 'bitmask' also depends on 'n'; ie i doubt you can assume each 'bitmask' is constant size
				- ie the 'bitmask' is n bits long...idk how this translates into  high level space complexity tho, i'm not familiar with bits/etc
		- its probably like O(nlogn) or something; ie the bitmask is size logn


![](../!assets/attachments/Pasted%20image%2020240225150357.png)

![](../!assets/attachments/Pasted%20image%2020240225150412.png)





# "Efficient lookups" AND "Lazy storage"
- idea
	- with clever encodign/memoization, we only need a single set
	- previously, we used 3 structures to track of encountered numbers. and we used them via:
		- checking `row[i]` for `num`, or checking `row[i][num]` for `true`, you do:
	 - now instead: use one hashset `s` for everything, using an encoding:
		- check `s` for an encoding involving `row,i,num`
			- literally could just use the string `"row i num"` as the key
- strategy
	- initialize an empty set `seen`
	- for each `num = board[i][j]`
		- you test if the following strings exist in `seen`
			- `"num row i"`
			- `"num col j"`
			- `"num block k"`
		- if no collisions, then add them to the set
- the encoding
	- the "encoding" needs to make sure "different types of memoization elements are being constructed" for the row/col/blocks; ie so that "row elements" never "interfere" with "col elements", and etc etc
	- another example:
		- let `num = board[i][j]`
		- observe `num` is a string, not an integer
		- so the following tuples never "interfere"
			- `(num,i)` because it's `(string, int)`
			- `(j,num)` because it's `(int, string)`
			- `(num, i//3, j//3)` because it's size 3

another example encoding
![](../!assets/attachments/Pasted%20image%2020240226163609.png)


- another way to check for collisions:
	- instead of a set; instead initialize a list `seen`
	- iterate through nodes and add everything to a list `seen`
	- then at the end do `return len(set(seen) == len(seen)`


![](../!assets/attachments/Pasted%20image%2020240226165724.png)



- language tip
	- should be able to simultaneously "add to set" and "test for membership" at the same time
	- ie `s.add(x)` should also return a bool telling me if it alrdy existed or not

ie java example:
![](../!assets/attachments/Pasted%20image%2020240226163642.png)






# todo: claimed logn space
- complexity
	- O(n^2) time?
		- for each row (count n)
			- check duplicates..probly takes linear time
			- so ttl is O(n^2)
		- do same thing for cols, then blocks
	- O(logn) space
		- claimed
		- if this is true, then this is asymptotically the best method
			- but keep in mind: the constant for the time complexity is surely worse than the other methods; bc its like 3n^2, bc he loops through the puzzle 3 times
				- the other methods it should be just n^2
- below is a more unreadable/complicated example
	- btw according to realpython, map/zip are falling out of favor now..try to use generator expressions and comprehensions...
- me trying to figure out his jargon:
	- "using zip to transpose": ie so that rows of the transpose are columns of og puzzle
	- "generator to yield blocks": to check each 3x3 block
	- "bit memoization to check for unique digits":
		- go understand the `map()`
		- the `>>` is incrementing a bit
		- the `&` is some kind of boolean op, i forget...

![](../!assets/attachments/Pasted%20image%2020240225143930.png)


