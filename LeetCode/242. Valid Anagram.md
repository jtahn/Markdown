[242. Valid Anagram](https://leetcode.com/problems/valid-anagram/)

```
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        
```

Given two strings `s` and `t`, return `true` _if_ `t` _is an anagram of_ `s`_, and_ `false` _otherwise_.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

**Example 1:**  
**Input:** `s = "anagram", t = "nagaram"`  
**Output:** `true`  

**Example 2:**  
**Input:** `s = "rat", t = "car"`  
**Output:** `false`  

**Constraints:**
- `1 <= s.length, t.length <= 5 * 10^4`
- `s` and `t` consist of lowercase English letters.

**Follow up:** What if the inputs contain Unicode characters? How would you adapt your solution to such a case?

---

# Brute force
- strategy
	- for each permutation/anagram of `s`, check for equality with `t`
- complexity
	- time probably $O(n!)$
		- https://en.wikipedia.org/wiki/Permutation#Permutations_of_multisets
		- ![](../!assets/attachments/Pasted%20image%2020240314235441.png)

# Sorting
```
def isAnagram(self, s: str, t: str) -> bool:
        return sorted(s) == sorted(t)
```
- strategy
	- Sort, then compare for equality
- complexity
	- depends on sorting algo


# Hashing (better)
```
def isAnagram(self, s: str, t: str) -> bool:
    # return Counter(s) == Counter(t)

    counts_s = {}
    counts_t = {}

    ###########################
    # Body:
    # update counts_s, counts_t
    ###########################
    
    return counts_s == counts_t
```
- strategy
	- use a structure to store letter counts
		- dictionary or array
	- iterate through each string and store counts
	- compare counts
- python
	- oneliner via Counter class
- complexity
	- $O(n)$ time
		- O(n) to iterate through each string once to compute counts
		- O(1) to iterate through structures to compare counts
	- $O(1)$ space
		- 2 structures, each of size at most 26
