[494. Target Sum](https://leetcode.com/problems/target-sum/)

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        
```

# Description

You are given an integer array `nums` and an integer `target`.

You want to build an **expression** out of nums by adding one of the symbols `'+'` and `'-'` before each integer in nums and then concatenate all the integers.

- For example, if `nums = [2, 1]`, you can add a `'+'` before `2` and a `'-'` before `1` and concatenate them to build the expression `"+2-1"`.

Return the number of different **expressions** that you can build, which evaluates to `target`.

**Example 1:**  
**Input:** `nums = [1,1,1,1,1], target = 3`  
**Output:** `5`  
**Explanation:** There are 5 ways to assign symbols to make the sum of nums be target 3.
```
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

**Example 2:**  
**Input:** `nums = [1], target = 1`  
**Output:** `1`  

**Constraints:**
- `1 <= nums.length <= 20`
- `0 <= nums[i] <= 1000`
- `0 <= sum(nums[i]) <= 1000`
- `-1000 <= target <= 1000`

---


#/research 
- figure out why everyone brings up knapsack or 'partition subset sum'
	- i don't think these are actually optimal approaches here


#/meta 
- the 'maybe' tag indicates:
	- i'm trying to figure out the key ideas here
	- my ideas might be wrong


# References



# Results



# Strategies


## "dp"/hardway
- better time
- https://leetcodethehardway.com/solutions/0400-0499/target-sum-medium




## true backtracking
- better space




## tbd/algomonster
- https://algo.monster/liteproblems/494


## tbd/neetcode
- https://www.youtube.com/watch?v=g0npyaQtAQM&list=PLPe9IkX86X3y5m_MvtNu2ughxsvkqUNKr&index=115


#/maybe
- backtracking with no pruning
	- probly better space complexity than brute force
	- but probly no real time complexity benefits...bc still visit everything in search space
		- so think about whether a dp approach could work
- actually i don't think above is applicable here...idk if this is even backtracking, i think neetcode might be using wrong jargon
- 'backtracking' isn't even necessary for what i have in mind (ie check every possibility)
	- bc brute force doesn't use much space either
- seems actual important idea/observation:
	- naive description of search space: `2^n` possible strings
	- dp description of search space: `len(nums) * (sum(nums)*2)` subproblems
		- if nums allowed negative numbers...then it'd be like 'sum of abs values'



```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        dp = {}  # (index, total) -> # of ways

        def backtrack(i, total):
            if i == len(nums):
                return 1 if total == target else 0
            if (i, total) in dp:
                return dp[(i, total)]

            dp[(i, total)] = backtrack(i + 1, total + nums[i]) + backtrack(
                i + 1, total - nums[i]
            )
            return dp[(i, total)]

        return backtrack(0, 0)

```



