[49. Group Anagrams](https://leetcode.com/problems/group-anagrams/)

```
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        
```

Given an array of strings `strs`, group **the anagrams** together. You can return the answer in **any order**.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

**Example 1:**  
**Input:**` strs = ["eat","tea","tan","ate","nat","bat"]`  
**Output:** `[["bat"],["nat","tan"],["ate","eat","tea"]]`  

**Example 2:**  
**Input:** `strs = [""]`  
**Output:** `[[""]]`  

**Example 3:**  
**Input:** `strs = ["a"]`  
**Output:** `[["a"]]`  

**Constraints:**
- `1 <= strs.length <= 10^4`
- `0 <= strs[i].length <= 100`
- `strs[i]` consists of lowercase English letters.

---

# todo


- key idea:
	- this problem can be considered a 'comparison' problem
		- ie [242. Valid Anagram](242.%20Valid%20Anagram.md)
		- ie, 'do repeated comparisons'
		- but this is not the best interpretation
	- instead: consider it an existence problem
		- ie check if already started a group of its anagram
	- more generally: if a question is asking you to 'group things up'
		- it might be tempting to interpret this as: "the problem is asking us to compare things to determine if they belong to the same group"
		- but instead: you should interpret this as an existence problem: "we need to determine if this item belongs to a group that already exists"
	- why existence? bc we know we can efficiently do this via hashmaps
		- the problem then becomes: figuring out what key to use for each group
			- ie what key has best complexity for us
	- this lowkey seems like a very deep idea:
		- that in computing: checking for 'existence' seems like it's essentially never inefficient; and it's often most efficient
			- bc hashmap ops will only require O(1) time and O(n) space
		- so i should always try to see if i can phrase a problem in terms of existence, bc then that gives me a baseline algo that is alrdy fairly efficient?

- (bc of above key idea: can delete a lot of discussion below about how this problem is about 'efficiently doing repeated comparisons')

- key idea
	- if we need to make repeated existence checks:
		- immediately think about using a hash map
			- how do we use hashing?
				- think about what we need to check existence of
				- here: it’s of a ‘group of elements that aren’t identical’’
				- so we need to determine a hashable key that we can assign to each group
					- same key iff same group
				- from ‘valid anagram’
					- is it actually true that the optimal choice here is ‘structure of the counts’?
					- optimal choice
						- depends on what structures are hashable
							- i feel like other languages, dicts aren’t hashable..you’d have to implement your own hash function, which seems annoying / out of scope of this problem
							- if dictionary isnt hashable; then need to use a tuple of counts
							- but tuple is size of alphabet...if alphabet is large, this might not be efficient
						- so it also depends on ‘size of alphabet’ versus ‘size of words’
						- iirc for this problem in python: you use tuple of counts
							- O(n) time
	- since we need to do an ‘action’ after the existence check:
		- this probly is the general signal to use a dictionary
		- here the ‘action’ is: group items together
		- you use set if 'existence' is literally all you need
		- (maybe move this discussion to [1. Two Sum](1.%20Two%20Sum.md))




- jargon
	- doesnt seem like sets and dicts are generalizations of each other
		- what is the term that is the parent/generalization of both..is it “hashmap”?


- fundamental problem
	- in python, what containers are hashable
		- tuples are
		- lists arent?
		- dicts arent?






- [1. Two Sum](1.%20Two%20Sum.md)
	- should be fundamental problem for dictionaries in python
		- why key lookup is O(1)
			- (or actually this should be discussed in the fundamental problem for sets; and then i'll cite the explanation here, and say 'same arg')
		- copy stuff from realpython article
			- diff ways to initialize a dict
			- diff ways to add items and handle missing keys
			- defaultdict
				- common factory functions
					- list, tuple
			- Counter
				- actually two-sum doesn't use counter...imo diff problem should be fundamental for "Counter"
					- it's fine to split up counter; two-sum alrdy has a ton of stuff; and i'll have a TOC for 'fundamental topics'
- meta
	- actually no need to cite problem writeups; just tell them to refer to the "fundamental TOC"
		- once you review enough: i won't actually need to reference the links, bc i'll be reviewing those problems regularly anyways;
		- and i'll also have code snippet examples, which should be enough to jog my memory, even without 'detailed explanation'

		


# Observation
- comparison check to identify anagrams: we need to generate something so that they result in the same thing iff anagram
	- this is actually alrdy a leetcode problem, and we alrdy know the main solutions are
		- sorted word
			- complexity depends on sorting algo
		- array/dict of counts (better; we assume we use this technique)
			- O(m) time  (for word length m)

# Brute force
- strategy
	- use a list of lists to store anagrams
		- each inner list stores all the words that are anagrams of each other
	- iterate through the words: for each word:
		- check if its an anagram with an arbitrary member of each group
		- if no matches, then create its own group
- complexity (n is num word, m is length of longest string)
	- O(n^2 m)
		- O(n) from iterating over the words
		- then for each word: 
			- O(m) to compute that word's letter counts
			- another O(m) for each representative we have to check
				- worst case, no words are anagrams: so then checking all representatives is O(mn)
			- so O(m+mn) total
		- so O(n(m+mn))
	- space
		- O(nm) bc we want result to store the actual words
# Hashing
```
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        ans = collections.defaultdict(list)

        for s in strs:
            count = [0] * 26
            for c in s:
                count[ord(c) - ord("a")] += 1
            ans[tuple(count)].append(s)
        return ans.values()
```

- observation:
	- whatever check we do, the result can be hashed and used as a key; which means checking representatives now only takes O(1) time, instead of O(m)
	- ACTUALLY: we're not even checking representatives; we just append it to a group
	- so there's 2 speedups here: not only do we not have to recompute letter counts for representatives; but actually, there's no comparison step either. bc we just store the word at the key
		- the 'first' speedup is the real speedup
- strategy
	- use dictionary to store groups of anagrams
- complexity
	- time
		- O(mn)  
			- O(n) to loop over each word
			- for each word
				- O(m) to compute its key (via letter counts)
					- generally O(m log m) if you use sorted word as the key
				- O(1) to store word at the key
	- space
		- O(nm) bc solution array requires the actual words



