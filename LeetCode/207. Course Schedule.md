[207. Course Schedule](https://leetcode.com/problems/course-schedule/)

```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        
```

# Description

There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [a_i, b_i]` indicates that you **must** take course `b_i` first if you want to take course `a_i`.

- For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.

Return `true` if you can finish all courses. Otherwise, return `false`.

**Example 1:**  
**Input:** `numCourses = 2, prerequisites = [[1,0]]`  
**Output:** `true`
**Explanation:** There are a total of 2 courses to take.  
To take course 1 you should have finished course 0. So it is possible.

**Example 2:**  
**Input:** `numCourses = 2, prerequisites = [[1,0],[0,1]]`  
**Output:** `false`  
**Explanation:** There are a total of 2 courses to take.  
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.

**Constraints:**
- `1 <= numCourses <= 2000`
- `0 <= prerequisites.length <= 5000`
- `prerequisites[i].length == 2`
- `0 <= a_i, b_i < numCourses`
- All the pairs prerequisites[i] are **unique**.

---



# References

## process_edge


# Results


## direct acyclic graphs
- definitions
	- directed
	- acyclic




## graph edge basics

- bfs/dfs search tree associated with an undirected graph

so when we say tree edge: this means edge in the tree
all tree edges are graph edges; but not the other way around
the tree (edges) indicate order of how vertices are discovered

if a graph edge is not a tree edge, then it is a diff type of edge

'back edge'..ie edge to an ancestor (but not parent)


for dfs search tree associated with undirected graph: all edges are either tree or back edge

pg 230
(todo) it seems skiena does not consider parent/child as ancestor/descendent.
ie ancestor/descendant, it's as if he uses it to mean: at least one node btwn these nodes

no..on pg 224: he says 'immediate ancestor' aka parent


ohhh.... 'forward edge' he means like: the descendant is already in the search tree: and so now we encounter an edge from x to that descendant.
it'd be called a 'forward edge' bc we're referring to the order:
it's a 'forward edge' bc we discovered this edge via: descendant is in adjacency list of the ancestor

point is this can't happen in undirect dfs
but it can happen in directed


btw the jargon here supposed be: "the edge (x,y) encountered as we explore vertex x"


---

ok seems he never actually defines what forward/back/cross edges really are until p229..particularly look at figure 7.14



pg 230: this code is important: aka how to determine what type of edge


---

types of edges
- https://courses.cs.washington.edu/courses/cse417/21wi/lecture/06-DFS-model.pdf
- https://courses.cs.duke.edu/fall17/compsci330/lecture12note.pdf
- https://www.cs.cmu.edu/~15451-f17/lectures/lec11-DFS-strong-components.pdf
- 







## topological sort
- Topological sorting is the most important operation on directed acyclic graphs (DAGs). It orders the vertices on a line such that all directed edges go from left to right. Such an ordering cannot exist if the graph contains a directed cycle


two standard algos to do this
- https://en.wikipedia.org/wiki/Topological_sorting#Algorithms
- skiena mentions the dfs algo in ch 7.10
	- property of dfs
		- A directed graph is a DAG iﬀ no back edges are encountered
		- dfs on DAG constructs a topological sort
			- Labeling the vertices in the reverse order that they are marked processed deﬁnes a topological sort of a DAG
	- then in 18.2, mentions the kahn algo:
		- The conceptually simplest linear-time algorithm for topological sorting performs a depth-ﬁrst search of the DAG to identify the complete set of source vertices, meaning vertices of in-degree zero. At least one such source must exist in any DAG. Source vertices can appear at the front of any schedule without violating any constraints. Deleting all the outgoing edges of these source vertices will create new source vertices, which can then sit comfortably to the immediate right of the ﬁrst set. We repeat until all vertices are accounted for. With a modest amount of care using the right data structures (adjacency lists and queues), this runs in O(n + m) time.
		- An alternate algorithm makes use of the observation that ordering the vertices in terms of decreasing DFS ﬁnishing time yields a linear extension. An implementation of this algorithm with an argument for correctness is given in Section 7.10.1 (page 231).


(todo: implement the dfs version; since all the code examples below are for the kahn version)
(todo: decide whether i put this expo here, or in [210. Course Schedule II](210.%20Course%20Schedule%20II.md))
	feels like it should belong in 210
	then here i just cite it and say, this problem simpler bc we don't actually need to build the sorted list...we just care if there's a cycle or not




# Approaches

- [Topological Sorting | LeetCode The Hard Way](https://leetcodethehardway.com/tutorials/graph-theory/topological-sorting)

- [0207 - Course Schedule (Medium) | LeetCode The Hard Way](https://leetcodethehardway.com/solutions/0200-0299/course-schedule-medium)
- [207. Course Schedule - In-Depth Explanation](https://algo.monster/liteproblems/207)
- [207 - Course Schedule | Leetcode](https://leetcode.ca/2016-06-24-207-Course-Schedule/)
- [Course Schedule - Graph Adjacency List - Leetcode 207 - YouTube](https://www.youtube.com/watch?v=EgI5nU9etnU&list=PLPe9IkX86X3y5m_MvtNu2ughxsvkqUNKr&index=87)


- strategy:
	- define graph: (x,y) is an edge if y is a prereq of x
		- other way around is fine too, doesn't matter
	- solution: is a graph a DAG? aka does graph have a cycle or not 
	- approach: do dfs; return false if we find a back edge; otherwise true
	- (aka no need to even do a topological sort...but in the results section, probly might as well discuss top sort anyways...bc the reason for why there is no back edge is essentially the 'proof' of top sort...and this algo is essentially a top sort)



```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        # dfs
        preMap = {i: [] for i in range(numCourses)}

        # map each course to : prereq list
        for crs, pre in prerequisites:
            preMap[crs].append(pre)

        visiting = set()

        def dfs(crs):
            if crs in visiting:
                return False
            if preMap[crs] == []:
                return True

            visiting.add(crs)
            for pre in preMap[crs]:
                if not dfs(pre):
                    return False
            visiting.remove(crs)
            preMap[crs] = []
            return True

        for c in range(numCourses):
            if not dfs(c):
                return False
        return True

```