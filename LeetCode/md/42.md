https://leetcode.com/problems/trapping-rain-water/

Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.



**Example 1:**
![](../../!assets/attachments/Pasted%20image%2020240224212822.png)
**Input:** `height = [0,1,0,2,1,0,1,3,2,1,2,1]`
**Output:** `6`
**Explanation:** The above elevation map (black section) is represented by array `[0,1,0,2,1,0,1,3,2,1,2,1]`. In this case, 6 units of rain water (blue section) are being trapped.

**Example 2:**
**Input:** `height = [4,2,0,3,2,5]`
**Output:** `9`



**Constraints:**
- `n == height.length`
- `1 <= n <= 2 * 10^4`
- `0 <= height[i] <= 10^5`

---

# Observations


![](../../!assets/attachments/Pasted%20image%2020240226092147.png)

- boundaries for disjoint sets of trapped water will be monotone increasing, then monotone decreasing



# Brute force
- strategy
	- for each bar
		- find global max to left and right
		- subtract itself from min (global max left, global max right)
		- this value is amt of water that can be trapped directly above it
	- so the answer is the sum of all these values
- complexity
	- O(n^2) time
		- we iterate over each bar
		- for each bar, we iterate over array to check for global maxes
	- O(1) space

![](../../!assets/attachments/Pasted%20image%2020240226085452.png)

![](../../!assets/attachments/Pasted%20image%2020240226085439.png)





# dynamic programming
- strategy
	- from brute force: observe that this 'check for global max left and global max right' can actually be done at the beginning
		- create arrays to store global max left and right for each node
		- forwards pass to determine global max lefts
			- at each node, global max left is the highest height encountered so far
		- backwards pass to determine global max rights
			- same
- complexity
	- O(n) time
	- but now, O(n) space

![](../../!assets/attachments/Pasted%20image%2020240226091813.png)

![](../../!assets/attachments/Pasted%20image%2020240226092308.png)
![](../../!assets/attachments/Pasted%20image%2020240226092331.png)

![](../../!assets/attachments/Pasted%20image%2020240226092520.png)


![](../../!assets/attachments/Pasted%20image%2020240226092623.png)











# Two pointer
- possible intuition
	- from DP: the fact that global maxes at each node can be computed in one pass..maybe suggests that two pointer should let us achieve the same thing, but without space complexity
- 


![](../../!assets/attachments/Pasted%20image%2020240226090526.png)

![](../../!assets/attachments/Pasted%20image%2020240226010529.png)



![](../../!assets/attachments/Pasted%20image%2020240226005607.png)



![](../../!assets/attachments/Pasted%20image%2020240226005507.png)

![](../../!assets/attachments/Pasted%20image%2020240226005514.png)


![](../../!assets/attachments/Pasted%20image%2020240226005529.png)




![](../../!assets/attachments/Pasted%20image%2020240226010100.png)


![](../../!assets/attachments/Pasted%20image%2020240226093135.png)







## possible inspo?

'inefficient' 2 pointer
![](../../!assets/attachments/Pasted%20image%2020240226010154.png)




# Divide and conquer
![](../../!assets/attachments/Pasted%20image%2020240226010023.png)
![](../../!assets/attachments/Pasted%20image%2020240226010034.png)



# Stacks
![](../../!assets/attachments/Pasted%20image%2020240226090540.png)
![](../../!assets/attachments/Pasted%20image%2020240226090551.png)


![](../../!assets/attachments/Pasted%20image%2020240226010410.png)

![](../../!assets/attachments/Pasted%20image%2020240226010434.png)

![](../../!assets/attachments/Pasted%20image%2020240226010612.png)







# pochmann

![](../../!assets/attachments/Pasted%20image%2020240226010711.png)



