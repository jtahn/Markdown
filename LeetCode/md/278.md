You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.
Suppose you have  `n`  versions `[1,2,...,n]` and you want to find out the first bad one, which causes all the following ones to be bad.
You are given an API bool `isBadVersion(version)` which returns whether `version` is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.


![](../../!assets/attachments/Pasted%20image%2020240224140707.png)
![](../../!assets/attachments/Pasted%20image%2020240224140712.png)

- $1 \leq \texttt{bad} \leq n \leq 2^{31} - 1$

---


# binary search
- can do iterative or recursive

left=1 (not 0; bc versions start at 1)
right=n


idea: first bad version is always within inclusive range `[left,right]`

while left<right:

run api call on mid:
then you adjust ranges based on "all the versions after a bad version are also bad":

- if mid is bad (then first bad is here at the latest), then replace right with mid; so new range is `[left,mid]`
- if mid is good (then anything before mid is also good), then replace left with mid+1; so new range is `[mid+1,right]`


once `left==right`, return either


## overflow

apparently python wont overflow; but java,cpp can

avoid overflow error in other languages:
mid = left + (right-left) // 2

instead of
mid = (left + right) // 2

(because left+right might be above the int max)

or rather, it seems you might get stuck in an infinite loop (?)

![](../../!assets/attachments/Pasted%20image%2020240224140846.png)




