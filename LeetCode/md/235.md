Given a binary search tree, find the lowest common ancestor node of two given nodes in the BST.  
The LCA is defined between two nodes `p` and `q` as the lowest node in the tree that has both `p` and `q` as descendants (where we allow a node to be a descendant of itself).

![](../../!assets/attachments/Pasted%20image%2020240224131412.png)

- the number of nodes in the tree is in the range  $[2,10^5]$ 
- $-10^9 \leq \texttt{Node.val} \leq 10^9$ 
- all  `Node.val`  are unique
- $\texttt{p} \neq \texttt{q}$ 
- `p`  and  `q`  will exist in the BST

---


# iterative

pseudocode:
- wlog, p<=q
- starting at the root, descend until you find the x satisfying p <= x <= q
	- aka while not p <= x <= q

let x = LCA(p,q). then using the definition of BST and LCA, we have:

observation 1:
x clearly exists


observation 2: x is the unique ancestor that is either equal to one of p,q, or contains p,q on different subtrees

proof x contains on diff subtrees:
- if x had p,q in the same subtree, then it wouldn't be the LCA; bc it's child would a lower node that is also an ancestor 

proof no other node contains on diff subtrees:
- any parent of x has p,q in the same subtree
- any child of x is a parent of at most one of p,q (otherwise, x wouldnt be the LCA)


observation 3: 'diff subtrees' is equivalent to satisfying p <= x <= q

thus, strategy: find ancestor x satisfying p <= x <= q


# recursion

same as iterative: except at check if p<x<q:
recursively apply on x.child (depending on if x smaller than p or larger than q)
instead of iterative: set x=x.child and repeat check