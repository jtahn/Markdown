Given a binary search tree, find the lowest common ancestor node of two given nodes in the BST.  
The LCA is defined between two nodes `p` and `q` as the lowest node in the tree that has both `p` and `q` as descendants (where we allow a node to be a descendant of itself).

![](../../!assets/attachments/Pasted%20image%2020240224131412.png)

- the number of nodes in the tree is in the range  $[2,10^5]$ 
- $-10^9 \leq \texttt{Node.val} \leq 10^9$ 
- all  `Node.val`  are unique
- $\texttt{p} \neq \texttt{q}$ 
- `p`  and  `q`  will exist in the BST

---


# 'traversal'

- todo
	- idk what the official jargon/terminology is for this technique
		- there not actually be one: bc it seems the 'strategy' comes directly from knowing an equivalent characterization of the LCA condition (which is explained in the observations below)
		- once you know this property, then the 'algo' is just about traversing the tree based on this property
- notation
	- let x = LCA(p,q)
	- wlog p <= q
- observations (using the definition of BST and LCA)
	- x clearly exists
	- x is the unique ancestor that is either equal to one of p,q; or contains p,q on different subtrees
		- proof x contains on diff subtrees:
			- if x had p,q in the same subtree, then it wouldn't be the LCA; bc it's child would a lower node that is also an ancestor 
		- proof no other node contains on diff subtrees:
			- any parent of x has p,q in the same subtree
			- any child of x is a parent of at most one of p,q (otherwise, x wouldnt be the LCA)
	- 'diff subtrees' is equivalent to satisfying p <= x <= q
- strategy
	- find ancestor x satisfying p <= x <= q
	- iterative
		- starting at the root, descend until you find the x satisfying p <= x <= q
			- aka while not p <= x <= q
	- recursive
		- probly need an aux function?
		- checks if $p \leq x \leq q$
		- if not:
			- set x=x.child and repeat check
			- which child depends on if $x < p$  or $q < x$

