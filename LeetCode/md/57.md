https://leetcode.com/problems/insert-interval/

You are given an array of non-overlapping intervals `intervals` where `intervals[i] = [start_i, end_i]` represent the start and the end of the `i^th` interval and `intervals` is sorted in ascending order by `start_i`. You are also given an interval `newInterval = [start, end]` that represents the start and end of another interval.

Insert `newInterval` into `intervals` such that `intervals` is still sorted in ascending order by `starti` and `intervals` still does not have any overlapping intervals (merge overlapping intervals if necessary).

Return `intervals` _after the insertion_.



**Example 1:**
**Input:** `intervals = [[1,3],[6,9]], newInterval = [2,5]`
**Output:** `[[1,5],[6,9]]`

**Example 2:**
**Input:** `intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]`
**Output:** `[[1,2],[3,10],[12,16]]`
**Explanation:** Because the new interval `[4,8]` overlaps with `[3,5],[6,7],[8,10]`.



**Constraints:**
- `0 <= intervals.length <= 10^4`
- `intervals[i].length == 2`
- `0 <= start_i <= end_i <= 10^5`
- `intervals` is sorted by `start_i` in **ascending** order.
- `newInterval.length == 2`
- `0 <= start <= end <= 10^5`

---

# 'direct'
- strategy
	- ignore oldIntervals strictly left and right of newInterval
	- merge everything else (aka stuff that overlaps with newInterval)
- complexity
	- O(1) space
- observation
	- because old intervals are sorted by start:
	- once we find an old interval that starts strictly after: we can break, because we know rest of the old intervals also start strictly after 
- optimization: can merge outside the loop.
	- observe: oldIntervals sorted by start and don't overlap
	- so: the merged intervals have endpoints:
	- min of `intervals[i][0]` and `newInterval[0]`
	- max of `interval[j-1][1]` and `newInterval[1]`
- careful
	- need to make sure `intervals[i]` and `intervals[j-1]` actually exist
		- they will not if intervals is empty
- edge cases
	- intervals is empty
	- only 1 oldInterval