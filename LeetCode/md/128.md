https://leetcode.com/problems/longest-consecutive-sequence/

Given an unsorted array of integers `nums`, return _the length of the longest consecutive elements sequence._

You must write an algorithm that runs in `O(n)` time.

**Example 1:**
**Input:** `nums = [100,4,200,1,3,2]`
**Output:** `4`
**Explanation:** The longest consecutive elements sequence is `[1, 2, 3, 4]`. Therefore its length is 4.`

**Example 2:**
**Input:** `nums = [0,3,7,2,5,8,4,6,0,1]`
**Output:** `9`


**Constraints:**
- `0 <= nums.length <= 10^5`
- `-10^9 <= nums[i] <= 10^9`

---



# sorting (not allowed)
- strategy
	- sort array
	- iterate through array
		- keep track of
			- length of current sequence
			- length of longest sequence
		- reset current length if current entry is not +1 of previous entry
- not allowed bc time complexity of any sorting algo is above O(n)
	- ie at least O(N log n)
- O(1) space

![](../../!assets/attachments/Pasted%20image%2020240225160511.png)






# hashing (set)

![](../../!assets/attachments/Pasted%20image%2020240225180615.png)
![](../../!assets/attachments/Pasted%20image%2020240225180800.png)
![](../../!assets/attachments/Pasted%20image%2020240225180816.png)

![](../../!assets/attachments/Pasted%20image%2020240225180855.png)

![](../../!assets/attachments/Pasted%20image%2020240225180914.png)



ok so complexity worst case isnt O(n);
but point is this essentially wont happen

and mebe i should say amortized O(n)?






---

![](../../!assets/attachments/Pasted%20image%2020240225180333.png)
![](../../!assets/attachments/Pasted%20image%2020240225180411.png)


- 2 key ideas here
	- use the set to efficiently check if x+1 is in the set
		- convert array into a set, takes O(n) time
		- this means that membership testing is O(1)
	- determine if you have already incorporated this node as part of a consecutive subsequence. 2 ways:
		- another set telling you which nodes have been included in a subseq
		- using defining property of starting node of a subsequence: that x-1 doesnt exist in the set
			- aka you smartly iterate the array by only doing a 'forwards progression' (ie repeatedly checking if x+1) if you know that a number is the start of a new sequence
				- aka if x-1 is not present in the set
				- if x-1 is present in the set, then you just dont check for a sequence here; bc you will find this sequence later when your iteration hits x-1 (or maybe even further back)
- optimization:
![](../../!assets/attachments/Pasted%20image%2020240225180342.png)


![](../../!assets/attachments/Pasted%20image%2020240225180348.png)




![](../../!assets/attachments/Pasted%20image%2020240225174717.png)



![](../../!assets/attachments/Pasted%20image%2020240225153322.png)








![](../../!assets/attachments/Pasted%20image%2020240225152900.png)![](../../!assets/attachments/Pasted%20image%2020240225152929.png)

![](../../!assets/attachments/Pasted%20image%2020240225152937.png)


![](../../!assets/attachments/Pasted%20image%2020240225152944.png)






## actually this looks similar too
- i'm fairly certain this is same as other methods; it's just, instead of having a loop to iterate through nodes; he turns it into a recursive function
	- imo this actually means: this is worse, i dont see how this is O(n) time
- he called it 'top down Dynamic programming' with 'lru cache'
- strategy
	- basically: he has a recurisve function that, once you apply it to a number, it then basically checks how many consecutive numbers exist, and then returns length of that
	- and then he runs that recursive function on every node
- claimed complexity
	- O(n) time
		- this seems incorrect: running recursive function on each num should be O(n); since you run this on every number, then isn't this O(n^2)
	- O(n) space

![](../../!assets/attachments/Pasted%20image%2020240225175205.png)

yea seems like it's identical to this: (which apparently doesnt work bc it hits TLE)
![](../../!assets/attachments/Pasted%20image%2020240225175514.png)
![](../../!assets/attachments/Pasted%20image%2020240225175558.png)











## probly the same

![](../../!assets/attachments/Pasted%20image%2020240225173905.png)

![](../../!assets/attachments/Pasted%20image%2020240225174028.png)


## another probly the same as well


![](../../!assets/attachments/Pasted%20image%2020240225153111.png)

![](../../!assets/attachments/Pasted%20image%2020240225153122.png)




# ???


![](../../!assets/attachments/Pasted%20image%2020240225174145.png)
![](../../!assets/attachments/Pasted%20image%2020240225174219.png)
![](../../!assets/attachments/Pasted%20image%2020240225174236.png)
