[22. Generate Parentheses](https://leetcode.com/problems/generate-parentheses/)

```
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        
```

Given `n` pairs of parentheses, write a function to _generate all combinations of well-formed parentheses_.

**Example 1:**  
**Input:** `n = 3`  
**Output:** `["((()))","(()())","(())()","()(())","()()()"]`  

**Example 2:**  
**Input:** `n = 1`  
**Output:** `["()"]`  

**Constraints:**
- `1 <= n <= 8`

---

# todo
- why is the "bottom-up" approach correct?
	- ie why is the "inner/outer" claim correct?
- figure out the "name" i give the for the "approaches" and "observations"
	- ie for the "backtracking": seems the "observation" is like: "iteratively add a left or right parenthesis in a valid way"
	- for "bottom-up":...??
- 

# Brute force
- strategy
	- recursively generate all possible combos
	- once a combo is formed, ie the base/return case:
		- use an aux function `isValidParentheses` to check if it is well-formed
			- if so, store it
- complexity
	- time: $O(2^{2n} \cdot 2n)$
	- space: nth catalan number
		- bc we dont actually store every combo; we only store the ones that are well-formed

# "Backtracking"
```
"""ITERATIVE/stack"""
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        result = []
        left = right = 0
        q = [(left, right, '')]
        while q:
            left, right, s = q.pop()
            if len(s) == 2 * n:
                result.append(s)
            if left < n:
                q.append((left + 1, right, s + '('))
            if right < left:
                q.append((left, right + 1, s + ')'))
        return result



"""RECURSION"""
def generateParenthesis(self, n: int) -> List[str]:
	def dfs(left, right, s):
		if len(s) == n * 2:
			res.append(s)
			return 

		if left < n:
			dfs(left + 1, right, s + '(')

		if right < left:
			dfs(left, right + 1, s + ')')

	res = []
	dfs(0, 0, '')
	return res



"""alternative recursion, using diff cases"""
def generateParenthesis(self, n):
    if not n:
        return []
    left, right, ans = n, n, []
    self.dfs(left,right, ans, "")
    return ans

def dfs(self, left, right, ans, string):
    if right < left:
        return
    if not left and not right:
        ans.append(string)
        return
    if left:
        self.dfs(left-1, right, ans, string + "(")
    if right:
        self.dfs(left, right-1, ans, string + ")")


```


- (todo) what is the correct jargon here? so many things being thrown around
	- iterative, stack, recursion, backtracking, dfs
		- tbh: the space optimized solution seems like backtracking, because the calls/code actually does go 'backwards' and undo stuff after it completes things
		- the unoptimized version just seems like normal recursion
	- apparently:
		- recursion is stack, bc call stack
		- backtracking is more specific than recursion
		- iterative version of recursive function, uses a stack you create manually
		- dfs uses a stack
	- hardway, algomonster, hiepit all call it backtracking
		- use dfs to facilitate; aka to generate combinations
- observation
	- improve the brute force solution:
		- don't waste time completing a substring that you already know has no chance to be well-formed
- observation
	- equivalent conditions to "well-formed parentheses"
		- ![](../!assets/attachments/Pasted%20image%2020240307170509.png)
	- assuming that your approach is via building parenthesis that are potentially balanced: (ie never unbalanced yet): then you know that you have a well-formed string once either happen:
		- string length is 2n
		- num left is n, and num right is n
	- the way you immediately discard unbalanced attempts: if any happen:
		- l-r<0
			- aka l < r
		- n < l
		- n < r (though this alrdy be enforced by the above two)
	- If we have an even amount of open and close parentheses, we can only place an open parentheses, as there isn't anything to close. 
- note:
	- below strategy isn't the only way to implement the observations
		- see above, the 2 different recursions
		- and another way would be like: instead of keeping track of `right`; you keep track of how many unclosed left parenthesis you have, ie in a variable `open`; aka this tells you how many right parenthesis you can add...aka `open = left-right`
		- point is, these are all the same...so i dont think its important to focus on the particular choice; myexplanation here needs to be higher level (todo)
- strategy
	1. The idea is to add `')'` only after valid `'('`
	2. We use two integer variables `left` & `right` to see how many `'('` & `')'` are in the current string
	3. If `left < n` then we can add `'('` to the current string
	4. If `right < left` then we can add `')'` to the current string
	- ![](../!assets/attachments/Pasted%20image%2020240307221347.png)
- 
- complexity
	- vaguely, we know it is something like O(2^n), but less; because we're basically pruning some of the branches of all possible combos
	- Since it is Catalan number sequence, the complexity cannot be less that O(4^n / n^(3/2))
	- See the Asymptotic approximation of Catalan Numbers


![](../!assets/attachments/Pasted%20image%2020240307221415.png)



![](../!assets/attachments/Pasted%20image%2020240307170021.png)

- strategy
	- We add left or "(" parenthesis while not reaching the pair limit = n.
	- We add right or ")" only if we have added same number of left before to make sure the parathesis string is correct.
- jargon
	- it is backtracking (not just recursion)
		- backtracking = constrained recursion
			- An example would be, in tree/graph problems we could either 'check first if next node is unvisited (constrained recursion) and then recurse on next node' or "recurse first on next node and then return from inside recursion if next node is visited (backtracking)
		- when a recursion call comes out within the condition "open < max", the next call to backtrack() within the condition "close < open" is made without an "("
		- ![](../!assets/attachments/Pasted%20image%2020240307170751.png)



---


![](../!assets/attachments/Pasted%20image%2020240307221443.png)
![](../!assets/attachments/Pasted%20image%2020240307221513.png)



- optimization
	- (if this is asymptotically better space complexity, then maybe make this it's own heading)
	- 

```
"""
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        stack = []
        res = []

        def backtrack(openN, closedN):
            if openN == closedN == n:
                res.append("".join(stack))
                return

            if openN < n:
                stack.append("(")
                backtrack(openN + 1, closedN)
                stack.pop()
            if closedN < openN:
                stack.append(")")
                backtrack(openN, closedN + 1)
                stack.pop()

        backtrack(0, 0)
        return res
```



it seems you use a stack to save space complexity?

![](../!assets/attachments/Pasted%20image%2020240307170320.png)


code that aligns with recursion above:
![](../!assets/attachments/Pasted%20image%2020240307170230.png)



alternatively can write it like:
![](../!assets/attachments/Pasted%20image%2020240307170150.png)

![](../!assets/attachments/Pasted%20image%2020240307170355.png)







# (todo) it's either DP or Memoization (better?)
```
class Solution:
    def generateParenthesis(self, n):
        ans = [[] for _ in range(n+1)]
        ans[0] = [""]
        for k in range(n + 1):
            for i in range(k):
                for left in ans[i]:
                    for right in ans[k-i-1]:
                        ans[k].append("(" + left + ")" + right)
        
        return ans[-1]
```
- jargon
	- bottom-up DP
	- ??? apparently it's actually top-down?
- observation
	- The key insight is that all well-formed parentheses follow the same pattern of `(left)right`, where `left` and `right` are themselves well-formed parentheses
	- For each valid parentheses there smallest `k`, for which the first `k` symbols compose well-formed parentheses: `(left)right`. 
- strategy
	- Let us `ans[i]` be all valid parentheses of length `i`. Then we can generate them using recursion. 
		- For every `k in range(n+1)` and for every `i in range(k)` we choose left part and right part and append it to final answer. 
- jargon
	- Because we memorize our intermediate results, we can also say that we use dp approach here.
- complexity
	- Time complexity is
		- (apparently this is wrong!) O(C_n * n) = O(4^n/n^0.5), where C_n is Catalan number. 
		- apparently it's actually n^4
			- aka dp might be much better....
			- the reason is apparently bc: the backtracking approach fully evaluates every subproblem every time
			- here, they're able to avoid overlapping subproblems
	- Space complexity is the same.

---

![](../!assets/attachments/Pasted%20image%2020240307220706.png)

![](../!assets/attachments/Pasted%20image%2020240307220735.png)

---

![](../!assets/attachments/Pasted%20image%2020240307212849.png)
![](../!assets/attachments/Pasted%20image%2020240307212949.png)


---


another explanation: (see comments as well)
https://leetcode.com/problems/generate-parentheses/solutions/10127/an-iterative-method/

yea lots of good comments in that link, ie:

![](../!assets/attachments/Pasted%20image%2020240307220347.png)

