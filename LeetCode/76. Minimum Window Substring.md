[76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)

Given two strings `s` and `t` of lengths `m` and `n` respectively, return _the **minimum window substring_** _of_ `s` _such that every character in_ `t` _(**including duplicates**) is included in the window_. If there is no such substring, return _the empty string_ `""`.

A **substring** is a contiguous **non-empty** sequence of characters within a string.

The testcases will be generated such that the answer is **unique**.

**Example 1:**  
**Input:** `s = "ADOBECODEBANC", t = "ABC"`  
**Output:** `"BANC"`  
**Explanation:** The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.  

**Example 2:**  
**Input:** `s = "a", t = "a"`  
**Output:** `"a"`  
**Explanation:** The entire string s is the minimum window.  

**Example 3:**  
**Input:** `s = "a", t = "aa"`  
**Output:** `""`  
**Explanation:** Both 'a's from t must be included in the window.  
Since the largest window of s only has one 'a', return empty string.  

**Constraints:**
- `m == s.length`
- `n == t.length`
- `1 <= m, n <= 10^5`
- `s` and `t` consist of uppercase and lowercase English letters.

**Follow up:** Could you find an algorithm that runs in `O(m + n)` time?

---
# Brute force





# Sliding window
```
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        if t == "":
            return ""

        countT, window = {}, {}
        for c in t:
            countT[c] = 1 + countT.get(c, 0)

        have, need = 0, len(countT)
        res, resLen = [-1, -1], float("infinity")
        l = 0
        for r in range(len(s)):
            c = s[r]
            window[c] = 1 + window.get(c, 0)

            if c in countT and window[c] == countT[c]:
                have += 1

            while have == need:
                # update our result
                if (r - l + 1) < resLen:
                    res = [l, r]
                    resLen = r - l + 1
                # pop from the left of our window
                window[s[l]] -= 1
                if s[l] in countT and window[s[l]] < countT[s[l]]:
                    have -= 1
                l += 1
        l, r = res
        return s[l : r + 1] if resLen != float("infinity") else ""
```


- strategy
	- two pointers: start and end to mark of a sliding window
	- valid = all the target letters have been found in the current window
	- alternate between the following
		- phase 1: shift end/right pointer until window is valid
			- note: if this is impossible, then solution is empty string
		- phase 2: shift start/left pointer until window is invalid
			- update minWindowLength if necessary
	- determining validity in a more efficient way
		- use a variable that tells you how many letters have the correct frequency
- other base cases could manually add (tho seems, not necessary)
	- if len(t) > len(s): return ""


![](../!assets/attachments/Pasted%20image%2020240306120318.png)


![](../!assets/attachments/Pasted%20image%2020240306115747.png)
![](../!assets/attachments/Pasted%20image%2020240306115815.png)
![](../!assets/attachments/Pasted%20image%2020240306115832.png)



## clean code
```
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        
        # Define variables
        s_count, t_count = Counter(), Counter(t)
        
        l, r = 0, 0
        
        results = []
        
        while r <= len(s)-1:
                                    
            # Find valid window
            s_count[s[r]] += 1            
            r += 1
            if s_count & t_count != t_count:
                continue
                
            # Minimize this window
            while l < r:
                s_count[s[l]] -= 1 
                l += 1
                if s_count & t_count == t_count:
                    continue
                results.append(s[l-1:r])
                break
            
            
        # Return result
        if not results:
            return ""        
        return min(results, key=len)


"""concise"""
class Solution:
   def minWindow(self, s: str, t: str) -> str:
       s_count, t_count = Counter(), Counter(t)
       l = 0
       results = ""

       for r in range(len(s)):
           s_count[s[r]] += 1
           while (s_count & t_count == t_count):
               if len(s[l:r+1]) < len(results) or results == "":
                    results = s[l:r+1]
               s_count[s[l]] -= 1 
               l += 1
       return results
```


![](../!assets/attachments/Pasted%20image%2020240306114027.png)



## one hashmap

```
class Solution:
    # We are going to create a counter to count the characters of t, then as 
    # we come across them in s, decrement the count in our counter. If count
    # for that character is <= 0, we have more than enough characters in our
    # window to equal t. so we can increment a matches variable to track that.
    # Knowing that our goal is to:
    # 1. add characters to our window, and then update the counter, and matches.
    # remembering that matches increments when the count of the characters in our
    # window reaches 0.
    # 2. Check to see if our window has all characters we need.
    # If so, we set our window to the current window, and start shrinking it to see
    # if it still remains true while shrinking. While shrinking, if the count of
    # the characters ever goes back positive, we know that we no longer have enough
    # characters inside our window to match t, so we can decrement matches, and stop
    # shrinking the window.
    # Repeat the above process until our window's right side expands to larger than s.
    def minWindow(self, s: str, t: str) -> str:
        # Early Return if t is larger than s, we obviously can't find t in s.
        if len(t) > len(s): return ""
        #Create counter to count all characters in t. O(n) time where n length of t.
        counter = {}
        for ch in t:
            if ch not in counter:
                counter[ch] = 0
            counter[ch] += 1
        # Initialize variables create out sliding window. l to track left
        # side of our window starting at 0, matches to track the characters
        # we have enough of inside our window to match t, and an initial variable
        # to where our window will start, and how large it is. We use -1 to show
        # we don't have a window started that is valid yet, and len(s) + 1 as a 
        # window that will be large enough than any window we find, if we find one
        # will be smaller than it, and therefore trigger our update condition.
        l = 0
        matches = 0
        window_start = -1
        window_size = len(s) + 1
        # Expand our window tracking r, right side window, and incoming character, ch.
        # O(m) time to look through the string s. Where m is length of s.
        for r, ch in enumerate(s):
            # Check expanded window incoming character is in counter so we can add it.
            if ch in counter:
                counter[ch] -= 1
                # If count for ch reaches 0, we have more than enough character to match it.
                if counter[ch] == 0:
                    matches += 1
            # Check that the window has all the characters it needs, while it does,
            # shrink the window until it doesn't have all characters it needs.
            while len(counter) == matches:
                # get current window size
                current_window_size = (r-l) + 1
                # check current window < smallest window found.
                if current_window_size < window_size:
                    # update size of smallest window we found.
                    window_size = current_window_size
                    # update start of window we found.
                    window_start = l
                # start the removal of the left character, ie moving window forward.
                left_ch = s[l]
                # if left ch is a character we need to match t, 
                if left_ch in counter:
                    # check to see if we have 0 for a count of that character.
                    # if we do, we know by removing it, we will no longer have enough
                    # characters to match to t.
                    if counter[left_ch] == 0:
                        matches -= 1
                    # remove ch from window, by incrementing its count.
                    counter[left_ch] += 1
                # move the window forward.
                l += 1
        # return the answer by slicing. string from our start point to start point + size
        # only do this if we found a valid window. Note slicing in python takes O(n)
        # where n is length of s, to copy the string, then slice it properly.
        return s[window_start: window_start + window_size] if window_start != -1 else ""
```

## rarara
![](../!assets/attachments/Pasted%20image%2020240306112834.png)


![](../!assets/attachments/Pasted%20image%2020240306112918.png)```
```
class Solution(object):
    def minWindow(self, search_string, target):
        """
        :type s: str
        :type t: str
        :rtype: str
        """
        target_letter_counts = collections.Counter(target)
        start = 0
        end = 0
        min_window = ""
        target_len = len(target)        
        
        for end in range(len(search_string)):
			# If we see a target letter, decrease the total target letter count
			if target_letter_counts[search_string[end]] > 0:
                target_len -= 1

            # Decrease the letter count for the current letter
			# If the letter is not a target letter, the count just becomes -ve
			target_letter_counts[search_string[end]] -= 1
            
			# If all letters in the target are found:
            while target_len == 0:
                window_len = end - start + 1
                if not min_window or window_len < len(min_window):
					# Note the new minimum window
                    min_window = search_string[start : end + 1]
                    
				# Increase the letter count of the current letter
                target_letter_counts[search_string[start]] += 1
                
				# If all target letters have been seen and now, a target letter is seen with count > 0
				# Increase the target length to be found. This will break out of the loop
                if target_letter_counts[search_string[start]] > 0:
                    target_len += 1
                    
                start+=1
                
        return min_window
```




## pochmann optimization

![](../!assets/attachments/Pasted%20image%2020240306113107.png)

---


Add three lines to make the code possibly easier to understand:

```
def minWindow(s, t):
    need = collections.Counter(t)            #hash table to store char frequency
    missing = len(t)                         #total number of chars we care
    start, end = 0, 0
    i = 0
    for j, char in enumerate(s, 1):          #index j from 1
        if need[char] > 0:
            missing -= 1
        need[char] -= 1
        if missing == 0:                     #match all chars
            while i < j and need[s[i]] < 0:  #remove chars to find the real start
                need[s[i]] += 1
                i += 1
            need[s[i]] += 1                  #make sure the first appearing char satisfies need[char]>0
            missing += 1                     #we missed this first char, so add missing by 1
            if end == 0 or j-i < end-start:  #update window
                start, end = i, j
            i += 1                           #update i to start+1 for next window
    return s[start:end]
```


![](../!assets/attachments/Pasted%20image%2020240306113217.png)


it helped me to understand the problem. However, I found it better if we interchange the window update & decreasing the size of window code pieces. Below, is slightly modified version:


```
class Solution:
    def minWindow(self, s: str, t: str) -> str:

        # hash table to store the required char frequency
        need = collections.Counter(t)            

        # total character count we need to care about
        missing = len(t)                         

        # windowStart and windowEnd to be
        windowStart, windowEnd = 0, 0
        i = 0


        # iterate over s starting over index 1
        for j, char in enumerate(s, 1):          
            
            # if char is required then decrease missing
            if need[char] > 0:                   
                missing -= 1

            # decrease the freq of char from need (maybe be negative - which basically denotes
            #   that we have few extra characters which are not required but present in between current window)
            need[char] -= 1                      

            # we found a valid window
            if missing == 0:                     
                # chars from start to find the real windowStart
                while i < j and need[s[i]] < 0:  
                    need[s[i]] += 1
                    i += 1

                # if it's only one char case or curr window is smaller, then update window
                if windowEnd == 0 or j-i < windowEnd-windowStart:  
                    windowStart, windowEnd = i, j

                # now resetting the window to make it invalid
                # sure the first appearing char satisfies need[char]>0
                need[s[i]] += 1          

                # missed this first char, so add missing by 1
                missing += 1                     

                #update i to windowStart+1 for next window
                i += 1                          

        return s[windowStart:windowEnd]
```



---


![](../!assets/attachments/Pasted%20image%2020240306113150.png)