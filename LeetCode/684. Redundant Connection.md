[684. Redundant Connection](https://leetcode.com/problems/redundant-connection/)

```python
class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        
```

# Description

In this problem, a tree is an **undirected graph** that is connected and has no cycles.

You are given a graph that started as a tree with `n` nodes labeled from `1` to `n`, with one additional edge added. The added edge has two **different** vertices chosen from `1` to `n`, and was not an edge that already existed. The graph is represented as an array `edges` of length `n` where `edges[i] = [a_i, b_i]` indicates that there is an edge between nodes `a_i` and `b_i` in the graph.

Return _an edge that can be removed so that the resulting graph is a tree of_ `n` _nodes_. If there are multiple answers, return the answer that occurs last in the input.

**Example 1:**  
![](!assets/attachments/Pasted%20image%2020240417153912.png)  
**Input:** `edges = [[1,2],[1,3],[2,3]]`  
**Output:** `[2,3]`

**Example 2:**  
![](!assets/attachments/Pasted%20image%2020240417153924.png)  
**Input:** `edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]`  
**Output:** `[1,4]`

**Constraints:**
- `n == edges.length`
- `3 <= n <= 1000`
- `edges[i].length == 2`
- `1 <= a_i < b_i <= edges.length`
- `a_i != b_i`
- There are no repeated edges.
- The given graph is connected.

---



# Result

## #trees/union_find
- https://en.wikipedia.org/wiki/Disjoint-set_data_structure

any approach: you'd have to read the entire array

the main idea: 
recall alt definition of a tree: redundant edge

and note problem description:
- want to return the last redundant edge
- but the description basically implies that this happens the first time we see a redundancy
	- ie the way this graph is built
- (i'm not a big fan of the explanation here atm)



so you know that, and it wants you to return the edge that was last in the input so it's very simple here, all you do is just keep adding edges and then if you add an edge to something that's already a component, then that's the edge that was redundant, and just return that and by the way, the reason this is correct is because you know only one redundant edge was added, so the moment you find it, you know that's the answer, because you know the rest of the edges and the rest of the solution are going to be they're not redundant, is the point like, they're connecting other stuff you know the point is, every single edge is going to be connecting distinct components, except for one of them and so the answer is just the edge that is not connecting a distinct component and you know the rest of the edges aren't going to do that I'm not happy right now with the I don't think I have the perfect explanation for this, but I think





# Approaches




```python
class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        par = [i for i in range(len(edges) + 1)]
        rank = [1] * (len(edges) + 1)

        def find(n):
            p = par[n]
            while p != par[p]:
                par[p] = par[par[p]]
                p = par[p]
            return p

        # return False if already unioned
        def union(n1, n2):
            p1, p2 = find(n1), find(n2)

            if p1 == p2:
                return False
            if rank[p1] > rank[p2]:
                par[p2] = p1
                rank[p1] += rank[p2]
            else:
                par[p1] = p2
                rank[p2] += rank[p1]
            return True

        for n1, n2 in edges:
            if not union(n1, n2):
                return [n1, n2]

```